<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS8系统换源安装（带GUI）</title>
    <url>/2023/10/09/Centos8-install/</url>
    <content><![CDATA[<p>最近在制作系统盘时发现使用ISO镜像文件安装CentOS 8系统时，在选择安装源时总是报错，显示错误的安装源。</p>
<p>后来查了一下资料，了解到CentOS 8操作系统已经结束了生命周期，社区已不再维护该操作系统版本。按照社区规则，CentOS 8的源地址内容已移除，目前第三方的镜像站中均已移除CentOS 8的源。但由于个人业务需要，仍需使用CentOS 8系统，因此我们需要换源在线安装。</p>
<h1 id="系统安装方法"><a href="#系统安装方法" class="headerlink" title="系统安装方法"></a>系统安装方法</h1><h2 id="确保网络连接"><a href="#确保网络连接" class="headerlink" title="确保网络连接"></a>确保网络连接</h2><p>由于安装过程是在线安装，因此需要确保设备连接了互联网，可使用ping操作验证:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure></div>


<h2 id="更换安装源"><a href="#更换安装源" class="headerlink" title="更换安装源"></a>更换安装源</h2><p>点击进入安装源，选择在网络上(On the network)，选择https:&#x2F;&#x2F;，URL类型(URL type)选择软件库URL(repository URL)，地址填写:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mirrors.aliyun.com/centos-vault/8.2.2004/BaseOS/x86_64/os/</span><br></pre></td></tr></table></figure></div>
<p>我安装的是Centos 8.2版本，使用阿里的源，也可以使用其他源。</p>

  <div class="note p-4 mb-4 rounded-small warning <i icon-padding">
    <i class="note-icon fa-solid fa-circle-exclamation"></i><p>我在这里没有勾选Appstream，因为勾选了Appstream后，后面的安装总是报错</p>

  </div>


<h2 id="选择软件"><a href="#选择软件" class="headerlink" title="选择软件"></a>选择软件</h2><p>由于没有勾选Appstream，在选择基本环境时只有三个选项：服务器，最小安装，定制操作系统。<br>我选择的是服务器，右侧额外软件可按需选择。</p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>除去上述操作，其他操作与使用ISO镜像文件安装CentOS 8系统时相同，就不赘述了。</p>
<p><strong>至此操作系统已安装完成，接下来安装桌面环境</strong></p>
<h1 id="桌面环境安装"><a href="#桌面环境安装" class="headerlink" title="桌面环境安装"></a>桌面环境安装</h1><h2 id="更换yum源"><a href="#更换yum源" class="headerlink" title="更换yum源"></a>更换yum源</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /etc/yum.repos.d/ /etc/yum.repos.d.back</span><br><span class="line"><span class="built_in">mkdir</span> /etc/yum.repos.d</span><br><span class="line">curl -O https://vault.centos.org/centos/8/AppStream/x86_64/os/Packages/wget-1.19.5-10.el8.x86_64.rpm</span><br><span class="line">curl -O https://vault.centos.org/centos/8/BaseOS/x86_64/os/Packages/libmetalink-0.1.3-7.el8.x86_64.rpm</span><br><span class="line">rpm -ivh libmetalink-0.1.3-7.el8.x86_64.rpm</span><br><span class="line">rpm -ivh wget-1.19.5-10.el8.x86_64.rpm</span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d</span><br><span class="line">wget http://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></div>
<h2 id="安装图形界面"><a href="#安装图形界面" class="headerlink" title="安装图形界面"></a>安装图形界面</h2><p>1.查看可用软件</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">yum grouplist</span><br></pre></td></tr></table></figure></div>
<p>可以看到有个选项是Server with GUI<br>2.下载桌面</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">yum groupinstall <span class="string">&quot;Server with GUI&quot;</span> -y</span><br></pre></td></tr></table></figure></div>
<p>3.设置默认自动启动</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl set-default graphical</span><br></pre></td></tr></table></figure></div>
<p>4.重启</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></div>
<p>至此安装完毕</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux操作</category>
      </categories>
  </entry>
  <entry>
    <title>I/O多路复用学习（二）do_select分析</title>
    <url>/2024/03/08/IO-Multiplexing-do-select/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一篇笔记：<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18081811" >I&#x2F;O多路复用学习（一）select <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，梳理了一下select的调用过程，这一篇笔记对其中的do_select函数的细节做一下简单的讨论。<br>本文中涉及的源码均出自Linux内核5.4.0版本</p>
<h1 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h1><p>了解相关的结构体可以帮助我们更好地理解select内部的实现<br>相关结构体关系示意图：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/08/IO-Multiplexing-do-select/struct.png"
                      alt="结构体关系图"
                ><figcaption>结构体关系图</figcaption></figure></p>
<h2 id="struct-poll-wqueues"><a href="#struct-poll-wqueues" class="headerlink" title="struct poll_wqueues"></a>struct poll_wqueues</h2><p><code>poll_wqueues</code>结构体（轮询等待队列）用于维护若干特定于文件描述符的设备驱动等待队列。但是它并不直接存储设备驱动等待队列本身；它通过<code>inline_entries[]</code>管理一个或多个<code>poll_table_entry</code>项，每个项与一个特定的文件描述符和其等待事件相关联。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/poll.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> &#123;</span></span><br><span class="line">	poll_table pt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">polling_task</span>;</span></span><br><span class="line">	<span class="type">int</span> triggered;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="type">int</span> inline_index;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">inline_entries</span>[<span class="title">N_INLINE_POLL_ENTRIES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="struct-poll-table-page"><a href="#struct-poll-table-page" class="headerlink" title="struct poll_table_page"></a>struct poll_table_page</h2><p><code>poll_table_page</code>结构体用于管理一组<code>poll_table_entry </code>对象，可以形成链表</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> * <span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> * <span class="title">entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">entries</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="struct-poll-table-struct"><a href="#struct-poll-table-struct" class="headerlink" title="struct poll_table_struct"></a>struct poll_table_struct</h2><p><code>poll_table_struct</code>是 Linux 内核中用于轮询机制的一个数据结构，其成员<code>_qproc</code>是一个函数指针，一般会被设置为<code>__pollwait</code>或<code>NULL</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/poll.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">	poll_queue_proc _qproc;</span><br><span class="line">	<span class="type">__poll_t</span> _key;</span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure></div>
<h2 id="struct-poll-table-entry"><a href="#struct-poll-table-entry" class="headerlink" title="struct poll_table_entry"></a>struct poll_table_entry</h2><p><code>poll_table_entry</code>用于管理与特定文件描述符相关的设备驱动等待队列</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/poll.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">	<span class="type">__poll_t</span> key;</span><br><span class="line">	<span class="type">wait_queue_entry_t</span> wait;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> *wait_address;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="wait-queue-head-t"><a href="#wait-queue-head-t" class="headerlink" title="wait_queue_head_t"></a>wait_queue_head_t</h2><p>等待队列头节点。这个等待队列的底层数据结构其实就是双向链表</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/wait.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span>		lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="wait-queue-entry-t"><a href="#wait-queue-entry-t" class="headerlink" title="wait_queue_entry_t"></a>wait_queue_entry_t</h2><p>等待队列的节点，每个<code>wait_queue_entry</code>实例代表一个在等待队列中等待特定事件的进程或线程</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/wait.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> <span class="title">wait_queue_entry_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;</span><br><span class="line">	<span class="type">void</span>			*private;</span><br><span class="line">	<span class="type">wait_queue_func_t</span>	func;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="fd-set-bits"><a href="#fd-set-bits" class="headerlink" title="fd_set_bits"></a>fd_set_bits</h2><p>内核中管理位图的结构体，<code>in</code>，<code>out</code>，<code>ex</code>用于表示输入，输出，异常的位图。<code>res_in</code>，<code>res_out</code>，<code>res_ex</code>用于存储输入，输出，异常事件的结果，当某个fd活跃时，结构体中对应的位就会被置1。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: fs/select.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *in, *out, *ex;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *res_in, *res_out, *res_ex;</span><br><span class="line">&#125; fd_set_bits;</span><br></pre></td></tr></table></figure></div>
<h1 id="do-select"><a href="#do-select" class="headerlink" title="do_select"></a>do_select</h1><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/08/IO-Multiplexing-do-select/do_select.png"
                      alt="do_select流程图"
                ><figcaption>do_select流程图</figcaption></figure></p>
<p>代码省略了一些，比如超时标志位<code>timed_out</code>的置位操作等。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: fs/select.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_select</span><span class="params">(<span class="type">int</span> n, fd_set_bits *fds, <span class="keyword">struct</span> timespec64 *end_time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">	poll_table *wait;</span><br><span class="line">	<span class="type">int</span> retval, i, timed_out = <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">	retval = max_select_fd(n, fds);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	n = retval;</span><br><span class="line"></span><br><span class="line">	poll_initwait(&amp;table);</span><br><span class="line">	wait = &amp;table.pt;</span><br><span class="line">	<span class="comment">//如果等待时间为0，则直接超时返回</span></span><br><span class="line">	<span class="comment">//如果设置了超时时间且超时时间设置为0（非阻塞）</span></span><br><span class="line">	<span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//超时标志位</span></span><br><span class="line">		timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line">		<span class="type">bool</span> can_busy_loop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">		rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, j;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">			<span class="type">__poll_t</span> mask;</span><br><span class="line">			<span class="comment">//按组获取读写异常的位图</span></span><br><span class="line">			in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">			<span class="comment">//读写异常三个位图按位与，判断对应fd是否需要监听</span></span><br><span class="line">			<span class="comment">//若一组fd都无需监听则直接跳过</span></span><br><span class="line">			all_bits = in | out | ex;</span><br><span class="line">			<span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">				i += BITS_PER_LONG;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//对于unsigned中的每个bit</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">				<span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//若遍历到的bit在all_bits中对应位为0，则无感兴趣事件，直接跳过</span></span><br><span class="line">				<span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="comment">//掩码初始化</span></span><br><span class="line">				mask = EPOLLNVAL;</span><br><span class="line">				<span class="comment">//fdget获取文件描述符对应的文件对象</span></span><br><span class="line">				<span class="comment">//会增加fd的引用计数</span></span><br><span class="line">				f = fdget(i);</span><br><span class="line">				<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">					wait_key_set(wait, in, out, bit,</span><br><span class="line">						     busy_flag);</span><br><span class="line">					<span class="comment">//返回文件描述符当前状态，比如若fd可读可写，则返回EPOLLIN | EPOLLOUT</span></span><br><span class="line">					mask = vfs_poll(f.file, wait);</span><br><span class="line">					<span class="comment">//减少fd的引用计数</span></span><br><span class="line">					fdput(f);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//检查是否有事件发生，并更新相关变量</span></span><br><span class="line">				<span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">					res_in |= bit;</span><br><span class="line">					retval++;</span><br><span class="line">					wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">					res_out |= bit;</span><br><span class="line">					retval++;</span><br><span class="line">					wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">					res_ex |= bit;</span><br><span class="line">					retval++;</span><br><span class="line">					wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将发生的事件拷贝出去；最终传给用户态使用</span></span><br><span class="line">			<span class="keyword">if</span> (res_in)</span><br><span class="line">				*rinp = res_in;</span><br><span class="line">			<span class="keyword">if</span> (res_out)</span><br><span class="line">				*routp = res_out;</span><br><span class="line">			<span class="keyword">if</span> (res_ex)</span><br><span class="line">				*rexp = res_ex;</span><br><span class="line">			<span class="comment">//完成一轮循环后，CPU放权，给紧急任务让渡CPU资源(有条件重调度)</span></span><br><span class="line">			cond_resched();</span><br><span class="line">		&#125;</span><br><span class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//如果有事件发生（`retval`不为0），超时（`timed_out`为1），或者当前进程收到挂起信号则停止循环检测 </span></span><br><span class="line">		<span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="poll-initwait"><a href="#poll-initwait" class="headerlink" title="poll_initwait"></a>poll_initwait</h2><p><code>poll_initwait</code>是do_select中比较关键的一个函数，它的作用是初始化<code>struct poll_wqueues</code>对象的成员：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">poll_initwait</span><span class="params">(<span class="keyword">struct</span> poll_wqueues *pwq)</span></span><br><span class="line">&#123;</span><br><span class="line">	init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);</span><br><span class="line">	pwq-&gt;polling_task = current;</span><br><span class="line">	pwq-&gt;triggered = <span class="number">0</span>;</span><br><span class="line">	pwq-&gt;error = <span class="number">0</span>;</span><br><span class="line">	pwq-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">	pwq-&gt;inline_index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(poll_initwait);</span><br></pre></td></tr></table></figure></div>
<p>其中的<code>init_poll_funcptr</code>函数就是将<code>__polwait</code>绑定到<code>pwq-&gt;pt-&gt;_qproc</code>上</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init_poll_funcptr</span><span class="params">(poll_table *pt, poll_queue_proc qproc)</span></span><br><span class="line">&#123;</span><br><span class="line">	pt-&gt;_qproc = qproc;</span><br><span class="line">	pt-&gt;_key   = ~(<span class="type">__poll_t</span>)<span class="number">0</span>; <span class="comment">/* all events enabled */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这就注册了<code>__pollwait</code>函数，他会在设备驱动调用自己的poll方法时被回调，后面会介绍。</p>
<h2 id="三层for循环"><a href="#三层for循环" class="headerlink" title="三层for循环"></a>三层for循环</h2><p>三层for循环也是do_select中的关键部分，下面我们逐层分析</p>
<h3 id="第一层for循环"><a href="#第一层for循环" class="headerlink" title="第一层for循环"></a>第一层for循环</h3><p>一个无限循环，代表一整次扫描。这个循环会一直进行，直到满足以下条件之一：有事件发生（<code>retval</code>不为0），超时（<code>timed_out</code>为1），或者当前进程收到挂起信号（<code>signal_pending(current)</code>为真）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line">	<span class="type">bool</span> can_busy_loop = <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//读写异常</span></span><br><span class="line">	inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">	rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line">	<span class="comment">//内层循环，遍历所有fd并进行操作</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//如果有事件发生（`retval`不为0），超时（`timed_out`为1），或者当前进程收到挂起信号则停止循环检测</span></span><br><span class="line">	<span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="第二层for循环"><a href="#第二层for循环" class="headerlink" title="第二层for循环"></a>第二层for循环</h3><p>第二层循环是以unsigned long为单位进行遍历。也就是说是以64bit（64位机）为一组，按组进行遍历。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">	<span class="type">__poll_t</span> mask;</span><br><span class="line">	<span class="comment">//按组获取读写异常的位图</span></span><br><span class="line">	in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">	<span class="comment">//读写异常三个位图按位与，判断对应fd是否需要监听</span></span><br><span class="line">	<span class="comment">//若一组fd都无需监听则直接跳过</span></span><br><span class="line">	all_bits = in | out | ex;</span><br><span class="line">	<span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">		i += BITS_PER_LONG;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//内层循环，对一组中的每个fd操作</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//将发生的事件拷贝出去；最终传给用户态使用</span></span><br><span class="line">	<span class="keyword">if</span> (res_in)</span><br><span class="line">		*rinp = res_in;</span><br><span class="line">	<span class="keyword">if</span> (res_out)</span><br><span class="line">		*routp = res_out;</span><br><span class="line">	<span class="keyword">if</span> (res_ex)</span><br><span class="line">		*rexp = res_ex;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中以读事件为例，<code>in</code>大小为64bit，代表64个fd。在本层循环开始时，<code>in</code>被赋值为<code>inp</code>指向的值（64bit），然后<code>inp</code>向后移动<code>sizeof(unsigned long)</code>个字节，指向后64bit的起始位置。以此实现了以unsigned long为单位的遍历。</p>
<p><code>all_bits</code>代表了一组fd中，每个fd在读，写，异常上是否有相应的事件需要监听，若64个fd在读，写，异常上都没有要监听的事件，则直接跳过本组。</p>
<h3 id="第三层for循环"><a href="#第三层for循环" class="headerlink" title="第三层for循环"></a>第三层for循环</h3><p>第三层循环是遍历一组中的所有fd，并对每个监听的fd做相应操作。这些操作中最关键的是<code>vfs_poll</code>，后面会详细介绍。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//若遍历到的bit在all_bits中对应位为0，则无感兴趣事件，直接跳过</span></span><br><span class="line">	<span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	<span class="comment">//掩码初始化</span></span><br><span class="line">	mask = EPOLLNVAL;</span><br><span class="line">	<span class="comment">//fdget获取文件描述符对应的文件对象</span></span><br><span class="line">	<span class="comment">//会增加fd的引用计数</span></span><br><span class="line">	f = fdget(i);</span><br><span class="line">	<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">		wait_key_set(wait, in, out, bit,</span><br><span class="line">			     busy_flag);</span><br><span class="line">		<span class="comment">//返回文件描述符当前状态，比如若fd可读可写，则返回EPOLLIN | EPOLLOUT</span></span><br><span class="line">		mask = vfs_poll(f.file, wait);</span><br><span class="line">		<span class="comment">//减少fd的引用计数</span></span><br><span class="line">		fdput(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检查是否有事件发生，并更新相关变量</span></span><br><span class="line">	<span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">		res_in |= bit;</span><br><span class="line">		retval++;</span><br><span class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">		res_out |= bit;</span><br><span class="line">		retval++;</span><br><span class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">		res_ex |= bit;</span><br><span class="line">		retval++;</span><br><span class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="循环总结"><a href="#循环总结" class="headerlink" title="循环总结"></a>循环总结</h3><p>总结一下三层循环：<br>第一层for循环就是进行select的一次扫描，包括</p>
<ul>
<li>扫描开始的变量初始化环节</li>
<li>中间for循环遍历fd的环节</li>
<li>扫描结束之前变量重置以及退出条件判断环节</li>
</ul>
<p>第二、三层for循环本质是遍历所有fd，并对每个感兴趣的fd做相应操作。操作中最关键的一步就是<code>vfs_poll</code>，后面会介绍。</p>
<h2 id="poll-freewait"><a href="#poll-freewait" class="headerlink" title="poll_freewait"></a>poll_freewait</h2><p>待讨论</p>
<h1 id="vfs-poll"><a href="#vfs-poll" class="headerlink" title="vfs_poll"></a>vfs_poll</h1><p>前面的select调用链提到，<code>vfs_poll</code>会调用设备驱动中的poll方法：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/poll.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">__poll_t</span> <span class="title function_">vfs_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *pt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!file-&gt;f_op-&gt;poll))</span><br><span class="line">		<span class="keyword">return</span> DEFAULT_POLLMASK;</span><br><span class="line">	<span class="keyword">return</span> file-&gt;f_op-&gt;poll(file, pt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>下面以socket中的tcp为例，继续对调用链进行分析：<br><code>vfs_poll</code>-&gt;<code>sock_poll</code>-&gt;<code>tcp_poll</code>-&gt;<code>sock_poll_wait</code>-&gt;<code>poll_wait</code>。<br>梳理调用链可以知道，最后调用到<code>poll_wait</code>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/poll.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">poll_wait</span><span class="params">(<span class="keyword">struct</span> file * filp, <span class="type">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">		p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>p-&gt;_qproc(filp, wait_address, p)</code>中的p就是<code>do_select</code>中的变量<code>wait</code>，因此这一行实际执行的操作就是回调<code>__pollwait</code>函数。<br>所以<code>vfs_poll</code>的主要操作就是调用设备的poll方法从而回调<code>__pollwait</code>函数。</p>
<h1 id="pollwait"><a href="#pollwait" class="headerlink" title="__pollwait"></a>__pollwait</h1><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/08/IO-Multiplexing-do-select/pollwait.png"
                      alt="pollwait"
                ><figcaption>pollwait</figcaption></figure></p>
<p><code>__pollwait</code>用于处理轮询时的等待队列。这个函数通过创建并初始化<code>poll_table_entry</code>实例，将等待进程（或线程）添加到指定设备或文件的等待队列中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: fs/select.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __pollwait(<span class="keyword">struct</span> file *filp, <span class="type">wait_queue_head_t</span> *wait_address,</span><br><span class="line">				poll_table *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//获取poll_wqueues,也就是do_select中的table变量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> =</span> container_of(p, <span class="keyword">struct</span> poll_wqueues, pt);</span><br><span class="line">	<span class="comment">//为设备驱动分配一个poll_table_entry实例</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span> =</span> poll_get_entry(pwq);</span><br><span class="line">	<span class="keyword">if</span> (!entry)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	entry-&gt;filp = get_file(filp);</span><br><span class="line">	entry-&gt;wait_address = wait_address;</span><br><span class="line">	entry-&gt;key = p-&gt;_key;</span><br><span class="line">	<span class="comment">//初始化等待队列项，注册pollwake</span></span><br><span class="line">	init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);</span><br><span class="line">	entry-&gt;wait.private = pwq;</span><br><span class="line">	<span class="comment">//将等待队列节点挂到等待队列中</span></span><br><span class="line">	add_wait_queue(wait_address, &amp;entry-&gt;wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中三个关键函数：<code>poll_get_entry</code>，<code>init_waitqueue_func_entry</code>，<code>add_wait_queue</code>，下面逐个介绍：</p>
<h2 id="poll-get-entry"><a href="#poll-get-entry" class="headerlink" title="poll_get_entry"></a>poll_get_entry</h2><p><code>poll_get_entry</code>用于分配一个poll_table_entry对象：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: fs/select.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> poll_table_entry *<span class="title function_">poll_get_entry</span><span class="params">(<span class="keyword">struct</span> poll_wqueues *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">table</span> =</span> p-&gt;table;</span><br><span class="line">	<span class="comment">//p-&gt;pt还有地，就从里面分配</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;inline_index &lt; N_INLINE_POLL_ENTRIES)</span><br><span class="line">		<span class="keyword">return</span> p-&gt;inline_entries + p-&gt;inline_index++;</span><br><span class="line">	<span class="comment">//p-&gt;pt没有地了，且NULL == p-&gt;table（说明还没有分配过）或p-&gt;table满了</span></span><br><span class="line">	<span class="keyword">if</span> (!table || POLL_TABLE_FULL(table)) &#123;</span><br><span class="line">		<span class="comment">//分配一页内存</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">new_table</span>;</span></span><br><span class="line">		new_table = (<span class="keyword">struct</span> poll_table_page *) __get_free_page(GFP_KERNEL);</span><br><span class="line">		<span class="comment">//分配失败</span></span><br><span class="line">		<span class="keyword">if</span> (!new_table) &#123;</span><br><span class="line">			p-&gt;error = -ENOMEM;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将分配的页链接到p中</span></span><br><span class="line">		new_table-&gt;entry = new_table-&gt;entries;</span><br><span class="line">		new_table-&gt;next = table;</span><br><span class="line">		p-&gt;table = new_table;</span><br><span class="line">		table = new_table;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回一个新页的第一个entry，并将指针后移一位，方便后面的分配</span></span><br><span class="line">	<span class="keyword">return</span> table-&gt;entry++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>poll_wqueues</code>内嵌的<code>poll_table_entry</code>数组<code>inline_entries[]</code> 的大小是固定的：<code>N_INLINE_POLL_ENTRIES</code>，如果空间已满，就会动态申请物理内存页并以链表的形式挂在<code>poll_wqueues</code>对象上统一管理。</p>
<p>所以源码中就有对<code>inline_entries</code>中<code>poll_table_entry</code>对象个数的判断：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;inline_index &lt; N_INLINE_POLL_ENTRIES</span><br></pre></td></tr></table></figure></div>

<p>若<code>inline_entries[]</code>还有空间，就从里面分配，若<code>inline_entries[]</code>没有空间了，且<code>NULL == p-&gt;table</code>（说明还没有分配过内存页）或<code>p-&gt;table</code>满了，就新分配一页内存。</p>
<p>那么如何判断一个<code>poll_table_page</code>对象是否还有地去存储<code>poll_table_entry</code>对象（内存页已满）?</p>
<p>源码中使用了一个名为<code>POLL_TABLE_FULL</code>的宏定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT		12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE		(_AC(1,UL) &lt;&lt; PAGE_SHIFT)    <span class="comment">//一个内存页的大小是4096字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLL_TABLE_FULL(table) \</span></span><br><span class="line"><span class="meta">	((unsigned long)((table)-&gt;entry+1) &gt; PAGE_SIZE + (unsigned long)(table))</span></span><br></pre></td></tr></table></figure></div>
<p>这个宏就是在分配<code>poll_table_entry</code>对象之前，先计算当前页是否还有空间存放新的<code>poll_table_entry</code>对象</p>
<p>我自己在<code>gcc 10.3.0</code>下测得<code>poll_table_entry</code>对象大小为64字节（<code>poll_table_entry</code>中的<code>key</code>和<code>wait_queue_entry_t</code>中的<code>flags</code>各有4字节对齐），而一个<code>poll_table_page</code>对象大小为4096字节，也就是说一个<code>poll_table_page</code>对象最多可以管理63个<code>poll_table_entry</code>对象。</p>
<p><code>POLL_TABLE_FULL</code>为true情况的示意图：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/08/IO-Multiplexing-do-select/poll_table_page.png"
                      alt="POLL_TABLE_FULL为真"
                ><figcaption>POLL_TABLE_FULL为真</figcaption></figure></p>
<h2 id="init-waitqueue-func-entry"><a href="#init-waitqueue-func-entry" class="headerlink" title="init_waitqueue_func_entry"></a>init_waitqueue_func_entry</h2><p><code>init_waitqueue_func_entry</code>用于初始化<code>wait_queue_entry</code>实例的各个成员。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/wait.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_waitqueue_func_entry</span><span class="params">(<span class="keyword">struct</span> wait_queue_entry *wq_entry, <span class="type">wait_queue_func_t</span> func)</span></span><br><span class="line">&#123;</span><br><span class="line">	wq_entry-&gt;flags		= <span class="number">0</span>;</span><br><span class="line">	wq_entry-&gt;private	= <span class="literal">NULL</span>;</span><br><span class="line">	wq_entry-&gt;func		= func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在<code>__pollwit</code>中有<code>init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);</code>，这是注册了<code>pollwake</code>函数，它会在设备驱动中被回调。</p>
<h2 id="add-wait-queue"><a href="#add-wait-queue" class="headerlink" title="add_wait_queue"></a>add_wait_queue</h2><p><code>add_wait_queue</code>主要用于将一个 <code>wait_queue_entry</code>对象添加到一个 <code>wait_queue_head</code> 指向的等待队列中（直接添加到头节点后面）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: kernel/sched/wait.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_wait_queue</span><span class="params">(<span class="keyword">struct</span> wait_queue_head *wq_head, <span class="keyword">struct</span> wait_queue_entry *wq_entry)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	wq_entry-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">	spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">	__add_wait_queue(wq_head, wq_entry);</span><br><span class="line">	spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add_wait_queue);</span><br></pre></td></tr></table></figure></div>
<p>查看源码可知其调用链为：<code>add_wait_queue</code>-&gt;<code>__add_wait_queue</code>-&gt;<code>list_add</code>-&gt;<code>__list_add</code><br><code>list_add</code>和<code>__list_add</code>源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: include/linux/list.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_add(new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!__list_add_valid(new, prev, next))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	next-&gt;prev = new;</span><br><span class="line">	new-&gt;next = next;</span><br><span class="line">	new-&gt;prev = prev;</span><br><span class="line">	WRITE_ONCE(prev-&gt;next, new);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可见底层是通过将<code>wq_entry-&gt;entry</code>链接到<code>wq_head-&gt;head</code>后面，从而实现的将一个 <code>wait_queue_entry</code>对象添加到一个 <code>wait_queue_head</code>指向的等待队列中。</p>
<h1 id="pollwake"><a href="#pollwake" class="headerlink" title="pollwake"></a>pollwake</h1><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/08/IO-Multiplexing-do-select/pollwake.png"
                      alt="pollwake"
                ><figcaption>pollwake</figcaption></figure></p>
<h2 id="回调过程"><a href="#回调过程" class="headerlink" title="回调过程"></a>回调过程</h2><p>前面提到<code>pollwake</code>会在设备驱动中被回调，下面简单梳理一下在设备驱动中的调用链，还是以socket中的tcp为例，当有数据包来临时函数的调用链为：<br><code>tcp_data_queue</code>-&gt;<code>sock_def_readable</code>-&gt;<code>wake_up_interruptible_sync_poll</code>-&gt;<code>__wake_up_sync_key</code>-&gt;<code>__wake_up_common_lock</code>-&gt;<code>__wake_up_common</code></p>
<p>在<code>__wake_up_common</code>中有<code>ret = curr-&gt;func(curr, mode, wake_flags, key);</code>,这里的<code>curr-&gt;func</code>就是之前注册好的pollwake。所以在数据来临时，pollwake会被回调，以唤醒当前进程。</p>
<h2 id="pollwake调用链"><a href="#pollwake调用链" class="headerlink" title="pollwake调用链"></a>pollwake调用链</h2><p><code>pollwake</code>-&gt;<code>__pollwake</code>-&gt;<code>default_wake_function</code>-&gt;<code>try_to_wake_up</code>。最终调用<code>try_to_wake_up</code>唤醒当前进程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文讨论了do_select函数调用链上的一些实现细节，梳理了相关结构体之间的关系。有些地方可能解释的不是很详细，后面持续更新。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a class="link"   href="https://blog.csdn.net/u012294613/article/details/126251930" >select 机制 - 访问方式（三） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内核源码</category>
      </categories>
  </entry>
  <entry>
    <title>I/O多路复用学习（一）select</title>
    <url>/2024/03/05/IO-Multiplexing-select/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要是简单讨论select的特点并梳理一下select的调用链，不涉及具体的使用方法。<br>本文中涉及的源码均出自Linux内核5.4.0版本</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>select 是一种 IO 多路复用的技术，它允许单个进程或线程高效地管理多个输入&#x2F;输出流，从而提高程序的性能和响应速度。</p>
<h1 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h1><h2 id="do-select"><a href="#do-select" class="headerlink" title="do_select"></a>do_select</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/05/IO-Multiplexing-select/doselect.png"
                      alt="select调用链"
                ><figcaption>select调用链</figcaption></figure></p>
<p>select的核心功能都在do_select中，里面的关键操作有：<br>1、poll_initwait：初始化轮询等待队列结构体 (<code>poll_wqueues</code>) 的所有字段，包括函数指针的初始化，后面用于驱动中回调<code>__pollwait</code>。<br>2、for循环：遍历每个fd并调用<code>vfs_poll</code>，<code>vfs_poll</code>针对传入的fd，调用其各自的poll函数（由设备驱动程序实现，比如<code>sock_poll</code>）。之后若满足一定条件则跳出循环。<br>3、poll_freewait：清理等待队列。</p>
<p>后面出一篇文章详细讨论do_select()<br><a class="link"   href="https://www.cnblogs.com/paw5zx/p/18081810" >I&#x2F;O多路复用学习（二）do_select分析 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="pollwait"><a href="#pollwait" class="headerlink" title="__pollwait"></a>__pollwait</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/05/IO-Multiplexing-select/pollwait.png"
                      alt="__pollwait调用链"
                ><figcaption>__pollwait调用链</figcaption></figure></p>
<p>__pollwait的作用是在等待队列上注册一个新的节点()，并初始化<code>poll_table_entry</code>的成员。<br>1、poll_get_entry：从轮询等待队列结构体 (<code>poll_wqueues</code>) 中获取一个空闲的<code>poll_table_entry</code>结构体实例<br>2、init_waitqueue_func_entry：初始化<code>poll_table_entry</code>结构体实例，包括函数指针的初始化，后面用于驱动中回调pollwake。<br>3、add_wait_queue：向等待队列添加一个节点</p>
<h2 id="pollwake"><a href="#pollwake" class="headerlink" title="pollwake"></a>pollwake</h2><p>当监视的文件描述符上发生了感兴趣的事件时（如可读，可写等），设备驱动将触发回调函数pollwake。pollwake会将进程或线程从睡眠状态唤醒。</p>
<h1 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h1><p>1、select默认支持的描述符有限，为1024（可以通过命令ulimit -n 2048临时修改，也可以修改Linux内核头文件posix_types.h修改__FD_SETSIZE的值，但是要重新编译内核）；<br>2、每次调用需要把fd集合在内核态和用户态间拷贝传递两次，在fdset很大时效率低；<br>3、select内部监视fd是通过轮询的方式，时间复杂度高，效率低；<br>4、每次调用后需要重新设置fdset，麻烦。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a class="link"   href="https://blog.csdn.net/u012294613/article/details/126251930" >select 机制 - 访问方式（三） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内核源码</category>
      </categories>
  </entry>
  <entry>
    <title>使用FModel提取《黑神话:悟空》的资产</title>
    <url>/2024/08/21/UE-fmodel-blackmyth-wukong/</url>
    <content><![CDATA[<p><a href="%E4%BD%BF%E7%94%A8FModel%E6%8F%90%E5%8F%96%E9%BB%91%E7%A5%9E%E8%AF%9D%E6%82%9F%E7%A9%BA%E7%9A%84%E8%B5%84%E4%BA%A7">TOC</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>黑神话悟空昨天上线了，解个包looklook。</p>
<ul>
<li>本文内容比较简洁，仅介绍解包黑神话所需的专项配置，关于FModel的基础使用流程，请见<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18304354" >《使用FModel提取UE4&#x2F;5游戏资产》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>本文仅演示steam平台下的解包过程</li>
</ul>
<h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p>在FModel的setting中修改以下选项：</p>
<ul>
<li>Archive Directory：<code>*\steamapps\common\BlackMythWukong（改成你游戏所在的路径）</code></li>
<li>UE Version: <code>GAME_BlackMythWukong (UE 5.0)</code></li>
<li>勾选Local Mapping File选项，并选择映射文件路径（映射文件的生成参考<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18304354" >《使用FModel提取UE4&#x2F;5游戏资产》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</li>
</ul>
<p>在Directory中添加AES：</p>
<ul>
<li>AES Key : <code>0xA896068444F496956900542A215367688B49B19C2537FCD2743D8585BA1EB128</code></li>
</ul>
<p>设置好之后重启软件，然后参照<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18304354" >《使用FModel提取UE4&#x2F;5游戏资产》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中的步骤查看或导出所需资产。</p>
<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>我主要是简单看一下角色的建模，因此下面的图片展示基本都是角色建模。</p>
<p>先看下咱猴哥的英俊面庞：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/21/UE-fmodel-blackmyth-wukong/1_wukong_face.png"
                     
                ></p>
<p>然后看下四大天王</p>
<p>持国天王：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/21/UE-fmodel-blackmyth-wukong/2_chiguo.png"
                     
                ></p>
<p>多闻天王<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/21/UE-fmodel-blackmyth-wukong/3_duowen.png"
                     
                ></p>
<p>广目天王<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/21/UE-fmodel-blackmyth-wukong/4_guangmu.png"
                     
                ></p>
<p>增长天王<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/21/UE-fmodel-blackmyth-wukong/5_zengzhang.png"
                     
                ></p>
<p>最后再看个小狗：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/21/UE-fmodel-blackmyth-wukong/6_dog.png"
                     
                ></p>
<h1 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h1><p>通过解包可以发现，黑神话里面的资源命名都是使用汉语拼音而非英文单词，不知道这是不是国内行业普遍使用的规矩。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/21/UE-fmodel-blackmyth-wukong/7_name.png"
                     
                ></p>
<p>至于为啥不使用英文，我猜一是有些中文词汇很难用英语翻译，强行翻译可能会词不达意；二是有些翻译会导致命名长度太长。</p>
<p>但是哥们儿，下面这个首字母简写我个人认为确实有一点点抽象了，能全部猜出来的也算是神人了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/21/UE-fmodel-blackmyth-wukong/8_name_hard.png"
                     
                ></p>
<p>由于一周目才刚开始打，我现在只能猜出来一部分：GYCY（观音禅院），HFM（黑风庙？），HGS（花果山），HYS（火焰山），LSH（流沙河？），LYS（雷音寺），MGD（埋骨地？），PSD（盘丝洞）。</p>
<h1 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h1><h2 id="没有相应的UE引擎版本选项"><a href="#没有相应的UE引擎版本选项" class="headerlink" title="没有相应的UE引擎版本选项"></a>没有相应的UE引擎版本选项</h2><p><strong>问题描述：</strong>在设置UE引擎版本时，下拉菜单中可能会没有<code>GAME_BlackMythWukong (UE 5.0)</code>这个选项。<br><strong>解决方法：</strong>在settings的update mode选项中选择<code>QA Testing</code>，然后软件会提示你更新，然后一路确定。待更新完成后重新打开软件，即可在<code>UE Version</code>中看到<code>GAME_BlackMythWukong (UE 5.0)</code>这个选项<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/21/UE-fmodel-blackmyth-wukong/9_version_solution.png"
                     
                ></p>
]]></content>
      <categories>
        <category>随便玩玩</category>
        <category>UE</category>
      </categories>
  </entry>
  <entry>
    <title>使用FModel提取UE4/5游戏资产</title>
    <url>/2024/07/16/UE-fmodel-usage/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章仅记录我作为初学者使用FModel工具提取某款游戏模型的过程。</p>
<h1 id="FModel简介"><a href="#FModel简介" class="headerlink" title="FModel简介"></a>FModel简介</h1><p>FModel是一个开源软件，可以用于查看和提取UE4-5项目中的资产。它支持从<code>.pak</code>和<code>.uasset</code>文件中提取内容，如3D模型，纹理，音频等。</p>
<h1 id="FModel安装"><a href="#FModel安装" class="headerlink" title="FModel安装"></a>FModel安装</h1><p>首先进入<a class="link"   href="https://fmodel.app/" >FModel官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，下载最新的发布版本。</p>
<p>下载后是一个压缩包，直接解压然后打开exe文件即可。</p>
<p>FModel还需要依赖<code>.NET</code>，如果你的系统中没有，则会提示你安装：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/1_fmodel.png"
                     
                ></p>
<p>安装好<code>.NET</code>之后，重新打开<code>FModel.exe</code>，此时软件可以正常打开。</p>
<h1 id="FModel使用"><a href="#FModel使用" class="headerlink" title="FModel使用"></a>FModel使用</h1><h2 id="初次使用"><a href="#初次使用" class="headerlink" title="初次使用"></a>初次使用</h2><p><strong>①软件初次打开会弹出这个界面</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/2_first_time.png"
                     
                ></p>
<p>这里可以随便设置，之后进入软件还可以更改。<br><strong>②点击ok进入软件</strong><br><strong>③设置填写AES key</strong><br>这里填写你要解包的游戏对应的AES key<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/3_aes.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/4_aes2.png"
                     
                ></p>
<p><strong>④设置选择UE版本和填写游戏路径</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/5_path.png"
                     
                ></p>
<p>⑤<strong>解包</strong><br>全选（我在使用时是这样，可能会因游戏的不同而不一样）然后load<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/6_unpack.png"
                     
                ></p>
<p>然后就会自动跳到Folder下，此时我们就可以随便选择一个资产双击进行查看<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/7_result.png"
                     
                ></p>
<p><strong>注意：</strong><br>如果你要解包的游戏是使用UE5开发的，那么在解包的时候可能会报错：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">[ERR] CUE4Parse.UE4.Exceptions.ParserException: Package has unversioned properties but mapping file is missing, can&#x27;t serialize</span><br><span class="line">   at CUE4Parse.UE4.Assets.IoPackage..ctor(FArchive uasset, IoGlobalData globalData, FIoContainerHeader containerHeader, Lazy`1 ubulk, Lazy`1 uptnl, IFileProvider provider, TypeMappings mappings)</span><br></pre></td></tr></table></figure></div>
<p>解决方案我放在附录中。</p>
<h2 id="资产预览"><a href="#资产预览" class="headerlink" title="资产预览"></a>资产预览</h2><p>FModel还提供了<code>3D Viewer</code>，<code>Audio Player</code>，<code>Image Merger</code>预览器，方便预览资产中的模型文件，音频文件和图片文件（直接在相应资产上双击即可）</p>
<p>比如<code>3D Viewer</code>的模型预览是这样<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/8_viewer.png"
                     
                ></p>
<h2 id="资产导出"><a href="#资产导出" class="headerlink" title="资产导出"></a>资产导出</h2><p>在<code>Settings</code>的<code>Models</code>中设置资产的导出格式（比如对于<code>mesh</code>可以设置导出为<code>.glb</code>，<code>texture</code>可以设置导出为<code>.png</code>）</p>
<p>然后在你要导出的资产上右键，选择要导出的类型即可：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/9_menu.png"
                     
                ></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="dumper"><a href="#dumper" class="headerlink" title="dumper"></a>dumper</h2><p>对于UE5+的游戏来说，具有<code>unversioned</code>属性的包是意料之中的。然而现在有一些解决方案可以让FModel支持对它们的解析。</p>
<p>下面将提供三种dumper，使用它们中的任意一个，可以生成一个映射文件（<code>*.usmap</code>），文件中是一些结构（schema），其包含游戏类、结构体和枚举。</p>
<p>注意，这种结构（schema）在每次游戏更新之后都会可能会发生变化，因此为了避免错误，应该在每次更新之后重新生成此文件。</p>
<p>三个dumper的链接（阅读它们的README文件来学习使用方法）：<br><a class="link"   href="https://github.com/Encryqed/Dumper-7" >https://github.com/Encryqed/Dumper-7 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://github.com/UE4SS-RE/RE-UE4SS" >https://github.com/UE4SS-RE/RE-UE4SS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://github.com/OutTheShade/UnrealMappingsDumper" >https://github.com/OutTheShade/UnrealMappingsDumper <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>当成功生成了<code>*.usmap</code>文件后，你可以在<code>FModel</code>软件的设置界面将其添加到<code>Mapping File Path</code>中：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/10_usmap.png"
                     
                ></p>
<p>下面我将演示通过使用<code>Dumper-7</code>生成<code>*.usmap</code>的过程</p>
<h2 id="Dumper-7生成usmap文件"><a href="#Dumper-7生成usmap文件" class="headerlink" title="Dumper-7生成usmap文件"></a>Dumper-7生成usmap文件</h2><p>①将Dumper-7项目git到本地<br>②使用Visual Studio打开<code>.sln</code>文件，将<code>Settings.h</code>中的<code>SDKGenerationPath</code>修改为你期望的usmap文件保存路径（默认路径为<code>C:/Dumper-7</code>）<br>③在x64-Release下编译，生成dll文件<br>④向目标游戏中注入dll（这一步我将在下面展开介绍）<br>⑤查看生成的usmap文件</p>
<h2 id="向游戏中注入dll"><a href="#向游戏中注入dll" class="headerlink" title="向游戏中注入dll"></a>向游戏中注入dll</h2><p>为了向游戏中注入dll，我们要使用一个工具：DLL Injector<br>官网链接：<a class="link"   href="https://dllinjector.net/" >DLL Injector官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>使用方法：<br>①打开DLL Injector<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/11_injector.png"
                     
                ></p>
<p>②选择要加载的DLL文件（有两种方法）：</p>
<ul>
<li>点击browse按钮然后选择你要加载的dll文件</li>
<li>拖拽你的dll文件到DLL injector软件的界面中<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/12_dll.png"
                     
                ></li>
</ul>
<p>③从左侧窗口中选择要注入DLL文件的目标进程</p>
<ul>
<li>可以在输入框中输入进程名称或进程号来筛选条目</li>
<li>如果使用筛选功能最后只筛选出一个进程，则此进程会被自动选中<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/13_select_pid.png"
                     
                ></li>
</ul>
<p>④点击右上方的注入按钮将DLL注入目标进程，结束后会在指定文件夹生成usmap文件<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/UE-fmodel-usage/14_inject.png"
                     
                ></p>
]]></content>
      <categories>
        <category>随便玩玩</category>
        <category>UE</category>
      </categories>
  </entry>
  <entry>
    <title>开源相机管理库Aravis例程学习（五）——camera-api</title>
    <url>/2024/04/28/aravis-camera-api/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文针对<a class="link"   href="https://github.com/AravisProject/aravis-c-examples" >官方例程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中的：03-camera-api做简单的讲解。并介绍其中调用的<code>arv_camera_get_region</code>，<code>arv_camera_get_pixel_format_as_string</code>，<code>arv_camera_get_pixel_format</code>，<code>ARV_PIXEL_FORMAT_BIT_PER_PIXEL</code>。</p>
<p>aravis版本：0.8.31<br>操作系统：ubuntu-20.04<br>gcc版本：9.4.0</p>
<h1 id="例程代码"><a href="#例程代码" class="headerlink" title="例程代码"></a>例程代码</h1><p>这段代码使用Aravis的API，获取相机的一些基本设置，如图像的宽度、高度和像素格式，主要操作步骤如下：</p>
<ul>
<li>连接相机</li>
<li>获取图像宽度，高度，像素格式等信息</li>
<li>释放资源</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier:Unlicense */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Aravis header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arv.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Standard headers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Connect to the first available camera, then display the current settings for image width and height, as well as the</span></span><br><span class="line"><span class="comment"> * pixel format, using the ArvCamera API.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	ArvCamera *camera;</span><br><span class="line">	GError *error = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//连接相机</span></span><br><span class="line">	camera = arv_camera_new (<span class="literal">NULL</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ARV_IS_CAMERA (camera)) &#123;</span><br><span class="line">		<span class="type">int</span> width;</span><br><span class="line">		<span class="type">int</span> height;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *pixel_format;</span><br><span class="line">		<span class="type">int</span> format_number;</span><br><span class="line">		<span class="type">int</span> bit_per_pixel;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Found camera &#x27;%s&#x27;\n&quot;</span>, arv_camera_get_model_name (camera, <span class="literal">NULL</span>));</span><br><span class="line">		<span class="comment">//获取图像宽度和高度</span></span><br><span class="line">		<span class="keyword">if</span> (!error) arv_camera_get_region (camera, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;width, &amp;height, &amp;error);</span><br><span class="line">		<span class="comment">//获取图像像素格式</span></span><br><span class="line">		<span class="keyword">if</span> (!error) pixel_format = arv_camera_get_pixel_format_as_string (camera, &amp;error);</span><br><span class="line">		<span class="keyword">if</span> (!error) format_number = arv_camera_get_pixel_format (camera, &amp;error);</span><br><span class="line">		<span class="comment">//获取图像像素位数</span></span><br><span class="line">		<span class="keyword">if</span> (!error) bit_per_pixel = ARV_PIXEL_FORMAT_BIT_PER_PIXEL (format_number);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;Width = %d\n&quot;</span>, width);</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;Height = %d\n&quot;</span>, height);</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;Pixel format = %s\n&quot;</span>, pixel_format);</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;Pixel format number = %d\n&quot;</span>, format_number);</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;Bit per pixel = %d\n&quot;</span>, bit_per_pixel);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		g_clear_object (&amp;camera);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* En error happened, display the correspdonding message */</span></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Error: %s\n&quot;</span>, error-&gt;message);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/04/28/aravis-camera-api/result.png"
                     
                ></p>
<h1 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h1><h2 id="arv-camera-get-region"><a href="#arv-camera-get-region" class="headerlink" title="arv_camera_get_region"></a>arv_camera_get_region</h2><p>简介：用于获取相机当前的感兴趣区域（ROI），此函数会将当前相机的ROI的位置坐标（x，y）和尺寸（width，height）通过指针返回，并记录错误信息。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">arv_camera_get_region</span> <span class="params">(</span></span><br><span class="line"><span class="params">  ArvCamera* camera,</span></span><br><span class="line"><span class="params">  gint* x,</span></span><br><span class="line"><span class="params">  gint* y,</span></span><br><span class="line"><span class="params">  gint* width,</span></span><br><span class="line"><span class="params">  gint* height,</span></span><br><span class="line"><span class="params">  GError** error</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure></div>
<p>其中：<br>[in]camera：相机对象<br>[out]x：ROI起始x坐标<br>[out]y：ROI起始y坐标<br>[out]width：ROI宽度<br>[out]height：ROI高度<br>[out]error：错误信息</p>
<p>Available since: 0.8.0</p>
<h2 id="arv-camera-get-pixel-format-as-string"><a href="#arv-camera-get-pixel-format-as-string" class="headerlink" title="arv_camera_get_pixel_format_as_string"></a>arv_camera_get_pixel_format_as_string</h2><p>简介：从连接的相机中获取当前设置的像素格式，以字符串形式返回。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">arv_camera_get_pixel_format_as_string</span> <span class="params">(</span></span><br><span class="line"><span class="params">  ArvCamera* camera</span></span><br><span class="line"><span class="params">  GError** error</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure></div>

<p>Available since: 0.8.0</p>
<h2 id="arv-camera-get-pixel-format"><a href="#arv-camera-get-pixel-format" class="headerlink" title="arv_camera_get_pixel_format"></a>arv_camera_get_pixel_format</h2><p>简介：从连接的相机中获取当前设置的像素格式，返回其编码。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ArvPixelFormat <span class="title function_">arv_camera_get_pixel_format</span><span class="params">(</span></span><br><span class="line"><span class="params">  ArvCamera* camera</span></span><br><span class="line"><span class="params">  GError** error</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure></div>

<p>Available since: 0.8.0</p>
<h2 id="ARV-PIXEL-FORMAT-BIT-PER-PIXEL"><a href="#ARV-PIXEL-FORMAT-BIT-PER-PIXEL" class="headerlink" title="ARV_PIXEL_FORMAT_BIT_PER_PIXEL"></a>ARV_PIXEL_FORMAT_BIT_PER_PIXEL</h2><p>简介：宏定义，用于获取pixel_format的第17位到第24位的值，其表示的是像素格式的Bpp(bits per pixel)。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARV_PIXEL_FORMAT_BIT_PER_PIXEL(pixel_format) (((pixel_format) &gt;&gt; 16) &amp; 0xff)</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>工业相机</category>
        <category>Aravis</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>开源相机管理库Aravis例程学习（六）——camera-features</title>
    <url>/2024/05/01/aravis-camera-features/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文针对<a class="link"   href="https://github.com/AravisProject/aravis-c-examples" >官方例程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中的：04-camera-features做简单的讲解。并介绍其中调用的<code>arv_camera_get_integer</code>，<code>arv_camera_get_string</code>。</p>
<p>aravis版本：0.8.31<br>操作系统：ubuntu-20.04<br>gcc版本：9.4.0</p>
<h1 id="例程代码"><a href="#例程代码" class="headerlink" title="例程代码"></a>例程代码</h1><p>这段代码使用Aravis的API，获取相机的一些基本设置，如图像的宽度、高度和像素格式，主要操作步骤如下：</p>
<ul>
<li>连接相机</li>
<li>获取图像宽度，高度，像素格式等信息</li>
<li>释放资源</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier:Unlicense */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Aravis header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Standard headers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Connect to the first available camera, then display the current settings for image width and height, as well as the</span></span><br><span class="line"><span class="comment"> * pixel format, using the more generic ArvCamera feature API.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	ArvCamera *camera;</span><br><span class="line">	GError *error = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//连接相机</span></span><br><span class="line">	camera = arv_camera_new (<span class="literal">NULL</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ARV_IS_CAMERA (camera)) &#123;</span><br><span class="line">		<span class="type">int</span> width;</span><br><span class="line">		<span class="type">int</span> height;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *pixel_format;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Found camera &#x27;%s&#x27;\n&quot;</span>, arv_camera_get_model_name (camera, <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Retrieve generally mandatory features for transmitters */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!error) width = arv_camera_get_integer (camera, <span class="string">&quot;Width&quot;</span>, &amp;error);</span><br><span class="line">		<span class="keyword">if</span> (!error) height = arv_camera_get_integer (camera, <span class="string">&quot;Height&quot;</span>, &amp;error);</span><br><span class="line">		<span class="keyword">if</span> (!error) pixel_format = arv_camera_get_string (camera, <span class="string">&quot;PixelFormat&quot;</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;Width = %d\n&quot;</span>, width);</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;Height = %d\n&quot;</span>, height);</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;Pixel format = %s\n&quot;</span>, pixel_format);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		g_clear_object (&amp;camera);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* En error happened, display the correspdonding message */</span></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Error: %s\n&quot;</span>, error-&gt;message);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个例程与<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18163483" >03-camera-api <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>实现的功能相似，但是不同的是本文的代码使用的是更为通用的API（<code>arv_camera_get_integer</code>和<code>arv_camera_get_string</code>）来获取的相机的参数。</p>
<p>我们查看03-camera-api中的<code>arv_camera_get_region</code>，<code>arv_camera_get_pixel_format_as_string</code>的函数定义可以发现，他们的底层其实就是通过调用<code>arv_camera_get_integer</code>和<code>arv_camera_get_string</code>来实现的相关功能：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: arvcamera.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arv_camera_get_region</span> <span class="params">(ArvCamera *camera, gint *x, gint *y, gint *width, gint *height, GError **error)</span></span><br><span class="line">&#123;</span><br><span class="line">	ArvCameraPrivate *priv = arv_camera_get_instance_private (camera);</span><br><span class="line">	GError *local_error = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	g_return_if_fail (ARV_IS_CAMERA (camera));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">		*x = priv-&gt;has_region_offset ? arv_camera_get_integer (camera, <span class="string">&quot;OffsetX&quot;</span>, &amp;local_error) : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (y != <span class="literal">NULL</span> &amp;&amp; local_error == <span class="literal">NULL</span>)</span><br><span class="line">		*y = priv-&gt;has_region_offset ? arv_camera_get_integer (camera, <span class="string">&quot;OffsetY&quot;</span>, &amp;local_error) : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (width != <span class="literal">NULL</span> &amp;&amp; local_error == <span class="literal">NULL</span>)</span><br><span class="line">		*width = arv_camera_get_integer (camera, <span class="string">&quot;Width&quot;</span>, &amp;local_error);</span><br><span class="line">	<span class="keyword">if</span> (height != <span class="literal">NULL</span> &amp;&amp; local_error == <span class="literal">NULL</span>)</span><br><span class="line">		*height = arv_camera_get_integer (camera, <span class="string">&quot;Height&quot;</span>, &amp;local_error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (local_error != <span class="literal">NULL</span>)</span><br><span class="line">		g_propagate_error (error, local_error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="title function_">arv_camera_get_pixel_format_as_string</span> <span class="params">(ArvCamera *camera, GError **error)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> arv_camera_get_string (camera, <span class="string">&quot;PixelFormat&quot;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/01/aravis-camera-features/result.png"
                     
                ></p>
<h1 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h1><h2 id="arv-camera-get-integer"><a href="#arv-camera-get-integer" class="headerlink" title="arv_camera_get_integer"></a>arv_camera_get_integer</h2><p>简介：获取已连接相机的一个整数型特性的值</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">gint64 <span class="title function_">arv_camera_get_integer</span> <span class="params">(</span></span><br><span class="line"><span class="params">  ArvCamera* camera,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* feature,</span></span><br><span class="line"><span class="params">  GError** error</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure></div>

<p>Available since: 0.8.0</p>
<h2 id="arv-camera-get-string"><a href="#arv-camera-get-string" class="headerlink" title="arv_camera_get_string"></a>arv_camera_get_string</h2><p>简介：获取已连接相机的一个字符串型特性的值</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">arv_camera_get_string</span> <span class="params">(</span></span><br><span class="line"><span class="params">  ArvCamera* camera,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* feature,</span></span><br><span class="line"><span class="params">  GError** error</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure></div>

<p>Available since: 0.8.0</p>
]]></content>
      <categories>
        <category>工业相机</category>
        <category>Aravis</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>开源相机管理库Aravis例程学习（七）——chunk-parser</title>
    <url>/2024/05/10/aravis-chunk-parser/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文针对<a class="link"   href="https://github.com/AravisProject/aravis-c-examples" >官方例程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中的：05-chunk-parser做简单的讲解。并介绍其中调用的<code>arv_camera_create_chunk_parser</code>，<code>arv_camera_set_chunks</code>，<code>arv_chunk_parser_get_integer_value</code>函数。</p>
<p>aravis版本：0.8.31<br>操作系统：ubuntu-20.04<br>gcc版本：9.4.0</p>
<h1 id="例程代码"><a href="#例程代码" class="headerlink" title="例程代码"></a>例程代码</h1><p>这段代码使用Aravis的API，操作相机捕获图像并获取流数据中附加的块信息（例程中启用的块数据为图像的长和宽），主要操作步骤如下：</p>
<ul>
<li>连接相机</li>
<li>设置启用的块数据</li>
<li>图像采集</li>
<li>打印相关数据</li>
<li>释放资源</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier:Unlicense */</span></span><br><span class="line"><span class="comment">/* Aravis header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arv.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Standard headers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	ArvCamera *camera;</span><br><span class="line">	ArvChunkParser *parser;</span><br><span class="line">	GError *error =<span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//连接相机</span></span><br><span class="line">	camera = arv_camera_new (<span class="literal">NULL</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ARV_IS_CAMERA (camera)) </span><br><span class="line">    &#123;</span><br><span class="line">		ArvBuffer *buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Found camera &#x27;%s&#x27;\n&quot;</span>, arv_camera_get_model_name (camera, <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建chunk parser对象</span></span><br><span class="line">		parser = arv_camera_create_chunk_parser (camera);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置启用的块数据</span></span><br><span class="line">		arv_camera_set_chunks (camera, <span class="string">&quot;Width,Height&quot;</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取单帧图像</span></span><br><span class="line">		<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">			buffer = arv_camera_acquisition	(camera, <span class="number">1000000</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (buffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;ChunkWidth = %d\n&quot;</span>, (<span class="type">int</span>) arv_chunk_parser_get_integer_value (parser,</span><br><span class="line">											       buffer, <span class="string">&quot;ChunkWidth&quot;</span>, <span class="literal">NULL</span>));</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;ChunkHeight = %d\n&quot;</span>, (<span class="type">int</span>) arv_chunk_parser_get_integer_value (parser,</span><br><span class="line">												buffer, <span class="string">&quot;ChunkHeight&quot;</span>, <span class="literal">NULL</span>));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;Failed to acquire a single buffer\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//释放资源</span></span><br><span class="line">		g_clear_object (&amp;buffer);</span><br><span class="line">		g_clear_object (&amp;parser);</span><br><span class="line">		g_clear_object (&amp;camera);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* En error happened, display the correspdonding message */</span></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Error: %s\n&quot;</span>, error-&gt;message);</span><br><span class="line">		g_clear_error (&amp;error);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/result.png"
                     
                ></p>
<h1 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h1><h2 id="arv-camera-create-chunk-parser"><a href="#arv-camera-create-chunk-parser" class="headerlink" title="arv_camera_create_chunk_parser"></a>arv_camera_create_chunk_parser</h2><p>简介：创建一个与camera关联的ArvChunkParser对象，用于从ArvBuffer中提取块数据</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ArvChunkParser* <span class="title function_">arv_camera_create_chunk_parser</span><span class="params">(ArvCamera* camera)</span></span><br></pre></td></tr></table></figure></div>

<p>Available since: 0.4.0</p>
<h2 id="arv-camera-set-chunks"><a href="#arv-camera-set-chunks" class="headerlink" title="arv_camera_set_chunks"></a>arv_camera_set_chunks</h2><p>简介：启用或禁用相机数据流中的块数据模式。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">arv_camera_set_chunks</span> <span class="params">(</span></span><br><span class="line"><span class="params">  ArvCamera* camera,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* chunk_list,    <span class="comment">//以逗号分隔的字符串列表，指定要启用的块数据类型</span></span></span><br><span class="line"><span class="params">  GError** error</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure></div>


<ul>
<li><p><strong>启用块数据</strong>：如果 <code>chunk_list</code> 是非空字符串，函数将解析这个字符串并启用列表中指定的所有块数据类型。这意味着这些数据将包含在相机输出的每帧图像数据中。</p>
</li>
<li><p><strong>禁用块数据</strong>：如果 <code>chunk_list</code> 是 <code>NULL</code> 或空字符串，这表示要禁用块数据模式。相机将停止发送所有块数据，只提供纯粹的图像数据。</p>
</li>
</ul>
<p><strong>未列出的所有块数据都被禁用</strong></p>
<p>Available since: 0.8.0</p>
<h2 id="arv-chunk-parser-get-integer-value"><a href="#arv-chunk-parser-get-integer-value" class="headerlink" title="arv_chunk_parser_get_integer_value"></a>arv_chunk_parser_get_integer_value</h2><p>简介：从相机的数据缓冲区中提取与给定名称匹配的块数据中的整数值</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">gint64 <span class="title function_">arv_chunk_parser_get_integer_value</span> <span class="params">(</span></span><br><span class="line"><span class="params">  ArvChunkParser* parser,</span></span><br><span class="line"><span class="params">  ArvBuffer* buffer,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* chunk,    <span class="comment">//一个字符串，指定要检索的块数据的名称</span></span></span><br><span class="line"><span class="params">  GError** error</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>工业相机</category>
        <category>Aravis</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>开源相机管理库Aravis学习——安装</title>
    <url>/2024/03/30/aravis-install/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做采集软件的开发，由于我自己使用过Huaray和Basler两个品牌的相机，所以在设计软件时尝试设计统一的接口去控制不同品牌和型号相机的相同或类似的行为。当然，我的设计思路都是建立在调用各品牌SDK的基础上。<br>后来我去外网搜索，发现了一个开源项目Aravis，它通过提供一个通用的API，让我们能够不受相机的品牌或型号限制，自由地进行图像采集和相机控制，支持从简单的图像捕获到复杂的相机设置调整的一系列操作。</p>
<p>项目地址：<a class="link"   href="https://github.com/AravisProject/aravis" >https://github.com/AravisProject/aravis <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h1 id="Aravis简介"><a href="#Aravis简介" class="headerlink" title="Aravis简介"></a>Aravis简介</h1><p>Aravis是一个基于glib&#x2F;gobject的库，允许开发者对遵循GenICam标准的网络相机进行通信和控制。它目前实现了工业相机使用的GigE和USB3协议。它还提供了一个简单的以太网相机模拟器和视频查看器。</p>
<h1 id="依赖关系说明"><a href="#依赖关系说明" class="headerlink" title="依赖关系说明"></a>依赖关系说明</h1><ul>
<li>Aravis库依赖于zlib、libxml2和glib2，若选择使用USB支持则需要依赖libusb1。</li>
<li>GStreamer插件除了需要Aravis库的依赖外，还依赖于GStreamer1。</li>
<li>视频查看器依赖于GStreamer1、Gtk+3以及Aravis库的依赖。</li>
<li>所需的版本在Aravis源码中的meson.build文件里有指定。</li>
<li>可以只构建库本身，以此将依赖减少到最少。</li>
</ul>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><h2 id="meson安装"><a href="#meson安装" class="headerlink" title="meson安装"></a>meson安装</h2><p>由于Aravis是使用meson进行项目构建的，所以我们先安装meson：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt install meson</span><br></pre></td></tr></table></figure></div>
<p>安装完毕后验证是否安装成功</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">meson --version</span><br></pre></td></tr></table></figure></div>
<h2 id="aravis源文件下载"><a href="#aravis源文件下载" class="headerlink" title="aravis源文件下载"></a>aravis源文件下载</h2><p><strong>作者对aravis使用者的建议是最好使用发行版本而不是直接git checkout</strong></p>
<p>在github上找到所需的aravis的发行版本，并下载：<a class="link"   href="https://github.com/AravisProject/aravis/releases" >https://github.com/AravisProject/aravis/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>我选择的是0.8.31版本：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/30/aravis-install/aravis_info.png"
                     
                ></p>
<p>下载压缩包后解压即可</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf aravis-0.8.31.tar.xz</span><br></pre></td></tr></table></figure></div>
<h2 id="构建和安装aravis"><a href="#构建和安装aravis" class="headerlink" title="构建和安装aravis"></a>构建和安装aravis</h2><p>进入工作目录，然后执行以下命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">meson setup build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">ninja</span><br><span class="line">ninja install</span><br></pre></td></tr></table></figure></div>
<p>在执行<code>meson setup build</code>可能会有安装失败的项点，错误解决方法可以参考文末的《安装过程中遇到的问题》</p>
<p><strong>&#x3D;&#x3D;至此安装已完成&#x3D;&#x3D;</strong></p>
<h1 id="视频查看器"><a href="#视频查看器" class="headerlink" title="视频查看器"></a>视频查看器</h1><p>找到Aravis双击打开，即可查看已连接的相机设备<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/30/aravis-install/video_viewer.png"
                     
                ></p>
<h1 id="安装过程中遇到的问题"><a href="#安装过程中遇到的问题" class="headerlink" title="安装过程中遇到的问题"></a>安装过程中遇到的问题</h1><h2 id="meson版本过低"><a href="#meson版本过低" class="headerlink" title="meson版本过低"></a>meson版本过低</h2><p>我安装的aravis版本是0.8.31，这个版本aravis的编译依赖0.57.0及以上版本的meson，而我通过apt包管理器下载的meson版本为0.53.2，不满足需求。因此要对meson进行升级操作：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/30/aravis-install/meson.png"
                     
                ></p>
<p>①首先安装或升级pip</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt install python3-pip</span><br><span class="line">或</span><br><span class="line">pip3 install --upgrade pip</span><br></pre></td></tr></table></figure></div>

<p>②然后移除旧版本meson避免版本冲突</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt remove meson</span><br></pre></td></tr></table></figure></div>
<p>③使用pip安装最新版本的meson<br>推荐使用–user选项，这样可以将Meson安装在用户目录下，避免对系统全局Python环境造成潜在的干扰</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade --user meson</span><br></pre></td></tr></table></figure></div>
<p>④更新环境变量<br>在<code>~/.bashrc</code>文件中添加</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/.local/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>然后重启系统生效</p>
<p>⑤验证meson版本<br>安装或升级完成后，通过以下命令检查Meson的版本，以确保安装或升级成功</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">meson --version</span><br></pre></td></tr></table></figure></div>
<p>我的安装结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/30/aravis-install/result.png"
                     
                ></p>
<h2 id="CMake版本过低"><a href="#CMake版本过低" class="headerlink" title="CMake版本过低"></a>CMake版本过低</h2><p>在构建项目的时候，提示了以下错误信息：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/30/aravis-install/cmake.png"
                     
                ></p>
<p>说明我系统中的CMake版本过低，需要升级。</p>
<p><strong>注意：apt包管理器中的CMake版本不是最新的，所以我们不使用<code>apt install</code>更新CMake</strong></p>
<p>我们采用从源码编译的方法更新：<br>①移除旧cmake防止版本冲突</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt remove cmake</span><br></pre></td></tr></table></figure></div>
<p>②下载源码<br>进入<a class="link"   href="https://cmake.org/download/" >CMake官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载所需版本的源码，我下载的是3.29.0发布版本</p>
<p>③解压下载的源码包</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf cmake-3.29.0.tar.gz</span><br></pre></td></tr></table></figure></div>
<p>④编译和安装CMake</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./cmake-*</span><br><span class="line">./bootstrap</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>
<p>⑤添加环境变量<br>在<code>~/.bashrc</code>中添加</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/path/to/cmake/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></div>
<p><code>/path/to/cmake</code>是解压出来的源码的路径</p>
<p>⑥验证CMake</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure></div>

<h2 id="缺少GStreamer组件"><a href="#缺少GStreamer组件" class="headerlink" title="缺少GStreamer组件"></a>缺少GStreamer组件</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/30/aravis-install/gstreamer.png"
                     
                ></p>
<p>直接使用包管理器安装即可</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev</span><br></pre></td></tr></table></figure></div>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a class="link"   href="https://aravisproject.github.io/aravis/aravis-stable/building.html" >Installation and Debug <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>工业相机</category>
        <category>Aravis</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>开源相机管理库Aravis例程学习（三）——注册回调multiple-acquisition-callback</title>
    <url>/2024/04/15/aravis-multiple-acquisition-callback/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文针对<a class="link"   href="https://github.com/AravisProject/aravis-c-examples" >官方例程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中的：02-multiple-acquisition-callback做简单的讲解。</p>
<p>aravis版本：0.8.31<br>操作系统：ubuntu-20.04<br>gcc版本：9.4.0</p>
<h1 id="例程代码"><a href="#例程代码" class="headerlink" title="例程代码"></a>例程代码</h1><p>这段代码使用Aravis的API，控制相机连续采集，并异步地在回调函数中获取10个有效图像，主要操作步骤如下：</p>
<ul>
<li>连接相机</li>
<li>设置采集模式为连续采集</li>
<li>创建流对象（同时注册回调），并向流对象的buffer池中添加buffer</li>
<li>开始采集</li>
<li>获取10张有效图像后停止采集</li>
<li>释放资源</li>
</ul>
<p>与<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18135154" >连续采集multiple-acquisition-main-thread <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>不同的是，本例中图像获取过程以及停止采集条件的改变都是异步进行的（在回调函数中）。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier:Unlicense */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Aravis header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arv.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Standard headers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LogManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于回调函数中传递和储存流的状态和计数器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	ArvStream *stream;</span><br><span class="line">	<span class="type">int</span> counter;</span><br><span class="line">	gboolean done;</span><br><span class="line">&#125; ArvStreamCallbackData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="comment">//根据不同的回调类型处理视频流事件</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">stream_callback</span> <span class="params">(<span class="type">void</span> *user_data, ArvStreamCallbackType type, ArvBuffer *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ArvStreamCallbackData *callback_data = (ArvStreamCallbackData *) user_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 回调函数内尽量不做非必要的耗时操作 */</span></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">		<span class="keyword">case</span> ARV_STREAM_CALLBACK_TYPE_INIT:</span><br><span class="line">			<span class="built_in">PAW_INFO</span>(<span class="string">&quot;ARV_STREAM_CALLBACK_TYPE_INIT&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ARV_STREAM_CALLBACK_TYPE_START_BUFFER:</span><br><span class="line">			<span class="built_in">PAW_INFO</span>(<span class="string">&quot;ARV_STREAM_CALLBACK_TYPE_START_BUFFER&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE:</span><br><span class="line">			<span class="built_in">PAW_INFO</span>(<span class="string">&quot;ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE&quot;</span>);</span><br><span class="line">			<span class="comment">//从buffer池中取出buffer</span></span><br><span class="line">			<span class="built_in">g_assert</span> (buffer == <span class="built_in">arv_stream_pop_buffer</span>(callback_data-&gt;stream));</span><br><span class="line">			<span class="built_in">g_assert</span> (buffer != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//检索10个有效buffer</span></span><br><span class="line">			<span class="keyword">if</span> (callback_data-&gt;counter &lt; <span class="number">10</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">arv_buffer_get_status</span>(buffer) == ARV_BUFFER_STATUS_SUCCESS)</span><br><span class="line">					<span class="built_in">PAW_INFO</span>(<span class="string">&quot;Acquired&quot;</span>&lt;&lt;<span class="built_in">arv_buffer_get_image_width</span>(buffer)&lt;&lt;<span class="string">&quot;x&quot;</span>&lt;&lt;<span class="built_in">arv_buffer_get_image_height</span>(buffer)&lt;&lt; <span class="string">&quot; buffer&quot;</span>);</span><br><span class="line">				<span class="built_in">arv_stream_push_buffer</span>(callback_data-&gt;stream, buffer);</span><br><span class="line">				callback_data-&gt;counter++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				callback_data-&gt;done = TRUE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ARV_STREAM_CALLBACK_TYPE_EXIT:</span><br><span class="line">			<span class="built_in">PAW_INFO</span>(<span class="string">&quot;ARV_STREAM_CALLBACK_TYPE_EXIT&quot;</span>);</span><br><span class="line">			<span class="comment">/* Stream thread ended */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Connect to the first available camera, then acquire 10 buffers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CLogManager&amp; p_log_instance = CLogManager::<span class="built_in">GetInstance</span>();</span><br><span class="line"></span><br><span class="line">	ArvCamera *camera;</span><br><span class="line">	GError *error = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//连接相机</span></span><br><span class="line">	camera = <span class="built_in">arv_camera_new</span> (<span class="string">&quot;192.168.6.63&quot;</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ARV_IS_CAMERA</span> (camera)) &#123;</span><br><span class="line">		ArvStreamCallbackData callback_data;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Found camera &#x27;%s&#x27;\n&quot;</span>, <span class="built_in">arv_camera_get_model_name</span> (camera, <span class="literal">NULL</span>));</span><br><span class="line">		<span class="comment">//设置相机采集模式为连续采集</span></span><br><span class="line">		<span class="built_in">arv_camera_set_acquisition_mode</span> (camera, ARV_ACQUISITION_MODE_CONTINUOUS, &amp;error);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化回调数据</span></span><br><span class="line">		callback_data.counter = <span class="number">0</span>;</span><br><span class="line">		callback_data.done = FALSE;</span><br><span class="line">		callback_data.stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">//创建流对象，注册回调</span></span><br><span class="line">			<span class="built_in">PAW_INFO</span>(<span class="string">&quot;create stream&quot;</span>);</span><br><span class="line">			callback_data.stream = <span class="built_in">arv_camera_create_stream</span> (camera, stream_callback, &amp;callback_data, &amp;error);</span><br><span class="line">			<span class="built_in">PAW_INFO</span>(<span class="string">&quot;create stream end&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ARV_IS_STREAM</span> (callback_data.stream)) &#123;</span><br><span class="line">			<span class="type">int</span> i;</span><br><span class="line">			<span class="type">size_t</span> payload;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Retrieve the payload size for buffer creation */</span></span><br><span class="line">			<span class="comment">//从相机对象中获取图像负载大小(每个图像的字节大小)</span></span><br><span class="line">			payload = <span class="built_in">arv_camera_get_payload</span> (camera, &amp;error);</span><br><span class="line">			<span class="built_in">PAW_INFO</span>(<span class="string">&quot;payload:&quot;</span> &lt;&lt; payload);</span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="comment">/* Insert some buffers in the stream buffer pool */</span></span><br><span class="line">				<span class="comment">//双缓冲</span></span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">					<span class="built_in">arv_stream_push_buffer</span> (callback_data.stream, <span class="built_in">arv_buffer_new</span> (payload, <span class="literal">NULL</span>));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="comment">/* Start the acquisition */</span></span><br><span class="line">				<span class="built_in">arv_camera_start_acquisition</span> (camera, &amp;error);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">while</span> (!callback_data.done) &#123;</span><br><span class="line">					<span class="built_in">usleep</span> (<span class="number">1000</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="comment">/* Stop the acquisition */</span></span><br><span class="line">				<span class="built_in">arv_camera_stop_acquisition</span> (camera, &amp;error);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Destroy the stream object */</span></span><br><span class="line">			<span class="built_in">g_clear_object</span> (&amp;callback_data.stream);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Destroy the camera instance */</span></span><br><span class="line">		<span class="built_in">PAW_INFO</span>(<span class="string">&quot;destroy stream&quot;</span>);</span><br><span class="line">		<span class="built_in">g_clear_object</span> (&amp;camera);</span><br><span class="line">		<span class="built_in">PAW_INFO</span>(<span class="string">&quot;destroy stream end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* En error happened, display the correspdonding message */</span></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Error: %s\n&quot;</span>, error-&gt;message);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注：<code>PAW_INFO</code>是我自定义的用于打印日志的宏</p>
<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/04/15/aravis-multiple-acquisition-callback/result.png"
                     
                ></p>
<p>其中&lt;&gt;之间的是线程号。</p>
<h1 id="arv-camera-create-stream"><a href="#arv-camera-create-stream" class="headerlink" title="arv_camera_create_stream"></a>arv_camera_create_stream</h1><p>在<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18135154" >连续采集multiple-acquisition-main-thread <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中我们简单介绍了<code>arv_camera_create_stream</code>函数，在那个例子中<code>callback</code>和<code>user_data</code>都被设置为NULL，表示不注册回调。而在本例中callback注册了一个我们自定义的函数<code>stream_callback</code>。至于<code>stream_callback</code>中为什么为switch结构我们在后面的讨论中会给出回答。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">stream_callback</span> <span class="params">(<span class="type">void</span> *user_data, ArvStreamCallbackType type, ArvBuffer *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ArvStreamCallbackData *callback_data = (ArvStreamCallbackData *) user_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">		<span class="keyword">case</span> ARV_STREAM_CALLBACK_TYPE_INIT:</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ARV_STREAM_CALLBACK_TYPE_START_BUFFER:</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE:</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ARV_STREAM_CALLBACK_TYPE_EXIT:</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="ArvStreamCallbackType"><a href="#ArvStreamCallbackType" class="headerlink" title="ArvStreamCallbackType"></a>ArvStreamCallbackType</h1><p>简介：一个枚举类，描述了流回调函数被调用的时间点。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">	ARV_STREAM_CALLBACK_TYPE_INIT,</span><br><span class="line">	ARV_STREAM_CALLBACK_TYPE_EXIT,</span><br><span class="line">	ARV_STREAM_CALLBACK_TYPE_START_BUFFER,</span><br><span class="line">	ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE</span><br><span class="line">&#125; ArvStreamCallbackType;</span><br></pre></td></tr></table></figure></div>
<h1 id="ArvStreamCallback"><a href="#ArvStreamCallback" class="headerlink" title="ArvStreamCallback"></a>ArvStreamCallback</h1><p>简介：<code>ArvStreamCallback</code>是一个函数指针类型，用于在实例化流对象时注册回调函数。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(* ArvStreamCallback)</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">void</span>* user_data,</span></span></span><br><span class="line"><span class="params"><span class="function">  ArvStreamCallbackType type,</span></span></span><br><span class="line"><span class="params"><span class="function">  ArvBuffer* buffer</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure></div>
<p>它在四种情况下会被调用：<br>①流接收线程的初始化时（只会被调用一次，对应type为<code>ARV_STREAM_CALLBACK_TYPE_INIT</code>）<br>②流接收线程的终止时（只会被调用一次，对应type为<code>ARV_STREAM_CALLBACK_TYPE_EXIT</code>）<br>③每一个buffer从缓冲队列被开始取出时（对应type为<code>ARV_STREAM_CALLBACK_TYPE_START_BUFFER</code>）<br>④每一个buffer从缓冲队列中取出完毕时（无论成功与否，对应type为<code>ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE</code>）</p>
<p>现在回答关于<code>stream_callback</code>中的switch结构的问题：</p>
<p>在调用<code>arv_camera_create_stream </code>注册回调完成后，会立即开启一个流接收线程，用于数据接收。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">arv_camera_create_stream</span> (camera, stream_callback, &amp;callback_data, &amp;error);</span><br></pre></td></tr></table></figure></div>
<p>在这个流线程初始化时，会调用<code>stream_callback</code>并向<code>type</code>传入<code>ARV_STREAM_CALLBACK_TYPE_INIT</code>。然后是在开启采集之后，会对每一帧满足上述情况③和情况④的图像，再调用<code>stream_callback</code>，并分别向<code>type</code>传入<code>ARV_STREAM_CALLBACK_TYPE_START_BUFFER</code>和<code>ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE</code>。最后在线程退出时最后调用一次<code>stream_callback</code>，并向<code>type</code>传入<code>ARV_STREAM_CALLBACK_TYPE_EXIT</code>。</p>
<p>回调函数中使用switch结构是为了根据不同的<code>type</code>参数值执行不同的操作，以实现在流线程的不同时间点完成用户自定义的相关操作。</p>
]]></content>
      <categories>
        <category>工业相机</category>
        <category>Aravis</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>开源相机管理库Aravis例程学习（二）——连续采集multiple-acquisition-main-thread</title>
    <url>/2024/04/15/aravis-multiple-acquisition-main-thread/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文针对<a class="link"   href="https://github.com/AravisProject/aravis-c-examples" >官方例程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中的：02-multiple-acquisition-main-thread做简单的讲解，并简单介绍其中调用的<code>arv_camera_set_acquisition_mode </code>，<code>arv_camera_create_stream</code>，<code>arv_camera_get_payload</code>，<code>arv_buffer_new </code>，<code>arv_stream_push_buffer</code>，<code>arv_camera_start_acquisition</code>，<code>arv_stream_pop_buffer</code>，<code>arv_camera_stop_acquisition</code>函数。</p>
<p>aravis版本：0.8.31<br>操作系统：ubuntu-20.04<br>gcc版本：9.4.0</p>
<h1 id="例程代码"><a href="#例程代码" class="headerlink" title="例程代码"></a>例程代码</h1><p>这段代码使用Aravis的API，控制相机连续采集，并在主线程中从缓冲区获取前10帧图像（假设不丢帧），主要操作步骤如下：</p>
<ul>
<li>连接相机</li>
<li>设置采集模式为连续采集</li>
<li>创建流对象，并向流对象的buffer池中添加buffer</li>
<li>开始采集</li>
<li>从buffer池中获取10个图像数据</li>
<li>停止采集</li>
<li>释放资源</li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier:Unlicense */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Aravis header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arv.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Standard headers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Connect to the first available camera, then acquire 10 buffers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ArvCamera *camera;</span><br><span class="line">	GError *error = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//连接相机</span></span><br><span class="line">	camera = <span class="built_in">arv_camera_new</span> (<span class="string">&quot;192.168.6.63&quot;</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ARV_IS_CAMERA</span> (camera)) &#123;</span><br><span class="line">		ArvStream *stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Found camera &#x27;%s&#x27;\n&quot;</span>, <span class="built_in">arv_camera_get_model_name</span> (camera, <span class="literal">NULL</span>));</span><br><span class="line">		<span class="comment">//设置相机采集模式为连续采集</span></span><br><span class="line">		<span class="built_in">arv_camera_set_acquisition_mode</span> (camera, ARV_ACQUISITION_MODE_CONTINUOUS, &amp;error);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="comment">//创建流对象</span></span><br><span class="line">			stream = <span class="built_in">arv_camera_create_stream</span> (camera, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ARV_IS_STREAM</span> (stream)) &#123;</span><br><span class="line">			<span class="type">int</span> i;</span><br><span class="line">			<span class="type">size_t</span> payload;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//从相机对象中获取图像负载大小(每个图像的字节大小)</span></span><br><span class="line">			payload = <span class="built_in">arv_camera_get_payload</span> (camera, &amp;error);</span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">					<span class="comment">//在流对象buffer池中插入两个buffer</span></span><br><span class="line">					<span class="built_in">arv_stream_push_buffer</span> (stream, <span class="built_in">arv_buffer_new</span> (payload, <span class="literal">NULL</span>));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="comment">//开始采集</span></span><br><span class="line">				<span class="built_in">arv_camera_start_acquisition</span> (camera, &amp;error);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">					ArvBuffer *buffer;</span><br><span class="line">					<span class="comment">//从流对象中获取buffer，此时buffer中已经包含了图像数据</span></span><br><span class="line">					buffer = <span class="built_in">arv_stream_pop_buffer</span> (stream);</span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">ARV_IS_BUFFER</span> (buffer)) &#123;</span><br><span class="line">						<span class="built_in">printf</span> (<span class="string">&quot;Acquired %d×%d buffer\n&quot;</span>,</span><br><span class="line">							<span class="built_in">arv_buffer_get_image_width</span> (buffer),</span><br><span class="line">							<span class="built_in">arv_buffer_get_image_height</span> (buffer));</span><br><span class="line">						<span class="comment">//将buffer放回流对象的buffer池中，而不是销毁</span></span><br><span class="line">						<span class="built_in">arv_stream_push_buffer</span> (stream, buffer);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="comment">//停止采集</span></span><br><span class="line">				<span class="built_in">arv_camera_stop_acquisition</span> (camera, &amp;error);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">g_clear_object</span> (&amp;stream);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">g_clear_object</span> (&amp;camera);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Error: %s\n&quot;</span>, error-&gt;message);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>此例程较为简单，每一步的细节查看注释即可，此处不过多讲解。</p>
<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/04/15/aravis-multiple-acquisition-main-thread/result.png"
                     
                ></p>
<h1 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h1><h2 id="arv-camera-set-acquisition-mode"><a href="#arv-camera-set-acquisition-mode" class="headerlink" title="arv_camera_set_acquisition_mode"></a>arv_camera_set_acquisition_mode</h2><p>简介：设置相机的采集模式</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">arv_camera_set_acquisition_mode</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	ArvCamera* camera,</span></span></span><br><span class="line"><span class="params"><span class="function">	ArvAcquisitionMode value,</span></span></span><br><span class="line"><span class="params"><span class="function">	GError** error</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure></div>
<p>其中value是个枚举值，可选的值有：<code>ARV_ACQUISITION_MODE_CONTINUOUS</code>，<code>ARV_ACQUISITION_MODE_SINGLE_FRAME</code>，<code>ARV_ACQUISITION_MODE_MULTI_FRAME</code>分别代表连续采集，单帧采集和多帧采集。</p>
<h2 id="arv-camera-create-stream"><a href="#arv-camera-create-stream" class="headerlink" title="arv_camera_create_stream"></a>arv_camera_create_stream</h2><p>简介：创建流对象<br>注意：最终必须调用g_object_unref()释放内存</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ArvStream* <span class="title">arv_camera_create_stream</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	ArvCamera* camera,</span></span></span><br><span class="line"><span class="params"><span class="function">	ArvStreamCallback callback,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">void</span>* user_data,</span></span></span><br><span class="line"><span class="params"><span class="function">	GError** error</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure></div>
<p>其中callback是个回调函数，用于数据帧的处理；user_data是向回调函数中传递的用户数据。本例中这两个参数均为NULL，表示不使用回调函数。</p>
<p>Available since: 0.2.0</p>
<h2 id="arv-camera-get-payload"><a href="#arv-camera-get-payload" class="headerlink" title="arv_camera_get_payload"></a>arv_camera_get_payload</h2><p>简介：从相机检索一个图像所需的存储空间大小。此值一般用于创建流缓冲区。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">guint <span class="title">arv_camera_get_payload</span><span class="params">(ArvCamera* camera, GError** error)</span></span></span><br></pre></td></tr></table></figure></div>
<p>Available since: 0.8.0</p>
<h2 id="arv-buffer-new"><a href="#arv-buffer-new" class="headerlink" title="arv_buffer_new"></a>arv_buffer_new</h2><p>简介：此函数用于创建一个新的缓冲区，专门用来存储视频流图像的数据。函数提供了灵活的内存管理选项，让调用者可以选择预先分配内存（后续可由调用者重新分配）或由函数来分配内存。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ArvBuffer* <span class="title">arv_buffer_new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">void</span>* preallocated)</span></span></span><br></pre></td></tr></table></figure></div>
<p>其中preallocated指向预分配的内存缓冲区。若此参数不为NULL，则指向的内存将用作缓冲区存储数据；为NULL则由函数分配内存。</p>
<p>Available since: 0.2.0</p>
<h2 id="arv-stream-push-buffer"><a href="#arv-stream-push-buffer" class="headerlink" title="arv_stream_push_buffer"></a>arv_stream_push_buffer</h2><p>简介：将一个buffer添加到一个特定的流中。当缓冲区被推送到流中时，流对象接管了该缓冲区对象的所有权。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">arv_stream_push_buffer</span><span class="params">(ArvStream* stream, ArvBuffer* buffer)</span></span></span><br></pre></td></tr></table></figure></div>

<p>Available since: 0.2.0</p>
<h2 id="arv-camera-start-acquisition"><a href="#arv-camera-start-acquisition" class="headerlink" title="arv_camera_start_acquisition"></a>arv_camera_start_acquisition</h2><p>简介：开始采集</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">arv_camera_start_acquisition</span><span class="params">(ArvCamera* camera, GError** error)</span></span></span><br></pre></td></tr></table></figure></div>

<p>Available since: 0.8.0</p>
<h2 id="arv-stream-pop-buffer"><a href="#arv-stream-pop-buffer" class="headerlink" title="arv_stream_pop_buffer"></a>arv_stream_pop_buffer</h2><p>简介：从流的输出队列中弹出一个buffer并返回。这个buffer可能包含无效的图像数据，调用者应在使用图像数据前检查其有效性。<br>若输出队列为空，则阻塞至数据来临。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ArvBuffer* <span class="title">arv_stream_pop_buffer</span><span class="params">(ArvStream* stream)</span></span></span><br></pre></td></tr></table></figure></div>

<p>Available since: 0.2.0</p>
<h2 id="arv-camera-stop-acquisition"><a href="#arv-camera-stop-acquisition" class="headerlink" title="arv_camera_stop_acquisition"></a>arv_camera_stop_acquisition</h2><p>简介：停止采集</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">arv_camera_stop_acquisition</span><span class="params">(ArvCamera* camera, GError** error)</span></span></span><br></pre></td></tr></table></figure></div>

<p>Available since: 0.8.0</p>
]]></content>
      <categories>
        <category>工业相机</category>
        <category>Aravis</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>开源相机管理库Aravis例程学习（四）——multiple-acquisition-signal</title>
    <url>/2024/04/25/aravis-multiple-acquisition-signal/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文针对<a class="link"   href="https://github.com/AravisProject/aravis-c-examples" >官方例程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中的：02-multiple-acquisition-signal做简单的讲解。并简单介绍其中调用的<code>g_main_loop_new</code>，<code>g_main_loop_run</code>，<code>g_main_loop_quit</code>，<code>g_signal_connect</code>，<code>arv_stream_set_emit_signals</code>。</p>
<p>aravis版本：0.8.31<br>操作系统：ubuntu-20.04<br>gcc版本：9.4.0</p>
<h1 id="例程代码"><a href="#例程代码" class="headerlink" title="例程代码"></a>例程代码</h1><p>这段代码使用Aravis的API，控制相机连续采集，并通过GLib的事件循环机制和GObject的信号系统异步地获取10个图像，主要操作步骤如下：</p>
<ul>
<li>连接相机</li>
<li>设置采集模式为连续采集</li>
<li>创建流对象，并向流对象的buffer池中添加buffer</li>
<li>设置流对象信号回调函数，并使能流对象信号发射</li>
<li>开始采集</li>
<li>启动事件循环</li>
<li>获取10张图像后关闭事件循环</li>
<li>关闭流对象信号发射，释放资源</li>
</ul>
<p>与<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18135154" >连续采集multiple-acquisition-main-thread <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>不同的是，本例中使用GMainLoop（GLib的事件循环）来处理异步事件，图像获取过程是异步进行的。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier:Unlicense */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Aravis header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arv.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Standard headers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LogManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	GMainLoop *main_loop;</span><br><span class="line">	guint32 counter;</span><br><span class="line">&#125; AppData;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">new_buffer_cb</span> <span class="params">(ArvStream *stream, <span class="type">void</span> *user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ArvBuffer *buffer;</span><br><span class="line">	AppData *app_data = <span class="built_in">static_cast</span>&lt;AppData*&gt;(user_data);</span><br><span class="line"></span><br><span class="line">	buffer = <span class="built_in">arv_stream_pop_buffer</span> (stream);</span><br><span class="line">	<span class="built_in">PAW_INFO</span>(<span class="string">&quot;Acquired&quot;</span>&lt;&lt;<span class="built_in">arv_buffer_get_image_width</span>(buffer)&lt;&lt;<span class="string">&quot;x&quot;</span>&lt;&lt;<span class="built_in">arv_buffer_get_image_height</span>(buffer)&lt;&lt; <span class="string">&quot; buffer&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">arv_stream_push_buffer</span> (stream, buffer);</span><br><span class="line"></span><br><span class="line">	app_data-&gt;counter++;</span><br><span class="line">	<span class="keyword">if</span> (app_data-&gt;counter == <span class="number">10</span>)</span><br><span class="line">		<span class="built_in">g_main_loop_quit</span> (app_data-&gt;main_loop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ArvCamera *camera;</span><br><span class="line">	AppData app_data;</span><br><span class="line">	GError *error = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	app_data.main_loop = <span class="built_in">g_main_loop_new</span> (<span class="literal">NULL</span>, FALSE);</span><br><span class="line">	app_data.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//连接相机</span></span><br><span class="line">	camera = <span class="built_in">arv_camera_new</span> (<span class="literal">NULL</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ARV_IS_CAMERA</span> (camera)) &#123;</span><br><span class="line">		ArvStream *stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Found camera &#x27;%s&#x27;\n&quot;</span>, <span class="built_in">arv_camera_get_model_name</span> (camera, <span class="literal">NULL</span>));</span><br><span class="line">		<span class="comment">//设置采集模式</span></span><br><span class="line">		<span class="built_in">arv_camera_set_acquisition_mode</span> (camera, ARV_ACQUISITION_MODE_CONTINUOUS, &amp;error);</span><br><span class="line">		<span class="comment">//创建流对象</span></span><br><span class="line">		<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">			stream = <span class="built_in">arv_camera_create_stream</span> (camera, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ARV_IS_STREAM</span> (stream)) &#123;</span><br><span class="line">			<span class="type">int</span> i;</span><br><span class="line">			<span class="type">size_t</span> payload;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//获取有效负载大小</span></span><br><span class="line">			payload = <span class="built_in">arv_camera_get_payload</span> (camera, &amp;error);</span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="comment">//设置流对象的缓冲区数量</span></span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">					<span class="built_in">arv_stream_push_buffer</span> (stream, <span class="built_in">arv_buffer_new</span> (payload, <span class="literal">NULL</span>));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//设置流对象信号回调函数</span></span><br><span class="line">			<span class="built_in">g_signal_connect</span> (stream, <span class="string">&quot;new-buffer&quot;</span>, <span class="built_in">G_CALLBACK</span> (new_buffer_cb), &amp;app_data);</span><br><span class="line">			<span class="comment">//设置流对象发射信号</span></span><br><span class="line">			<span class="comment">//当流对象接收到新的缓冲区时，发射new-buffer信号</span></span><br><span class="line">			<span class="built_in">arv_stream_set_emit_signals</span> (stream, TRUE);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//开始采集</span></span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="built_in">arv_camera_start_acquisition</span> (camera, &amp;error);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//启动主循环</span></span><br><span class="line">			<span class="built_in">PAW_INFO</span>(<span class="string">&quot;start main loop&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="built_in">g_main_loop_run</span> (app_data.main_loop);</span><br><span class="line">			<span class="built_in">PAW_INFO</span>(<span class="string">&quot;start main loop end&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="comment">//停止采集</span></span><br><span class="line">				<span class="built_in">arv_camera_stop_acquisition</span> (camera, &amp;error);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">arv_stream_set_emit_signals</span> (stream, FALSE);</span><br><span class="line">			<span class="built_in">g_clear_object</span> (&amp;stream);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">g_clear_object</span> (&amp;camera);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">g_main_loop_unref</span> (app_data.main_loop);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* En error happened, display the correspdonding message */</span></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Error: %s\n&quot;</span>, error-&gt;message);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注：<code>PAW_INFO</code>是我自定义的用于打印日志的宏</p>
<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/04/25/aravis-multiple-acquisition-signal/result.png"
                     
                ></p>
<p>其中&lt;&gt;之间的是线程号。</p>
<h1 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h1><h2 id="g-main-loop-new"><a href="#g-main-loop-new" class="headerlink" title="g_main_loop_new"></a>g_main_loop_new</h2><p>简介：GLib的API，构造GMainLoop对象</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GMainLoop* <span class="title">g_main_loop_new</span><span class="params">(GMainContext* context, gboolean is_running)</span></span></span><br></pre></td></tr></table></figure></div>
<p>其中：<br>[in]context：一个GMainContext，如果为NULL，将使用全局默认的main上下文<br>[in]is_running：设置为TRUE表示循环正在运行。这不是很重要，因为只要后面调用g_main_loop_run()就会将其设置为TRUE。</p>
<h2 id="g-main-loop-run"><a href="#g-main-loop-run" class="headerlink" title="g_main_loop_run"></a>g_main_loop_run</h2><p>简介：GLib的API，运行一个主循环，直到在循环中调用g_main_loop_quit()</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">g_main_loop_run</span><span class="params">(GMainLoop* loop)</span></span></span><br></pre></td></tr></table></figure></div>
<h2 id="g-main-loop-quit"><a href="#g-main-loop-quit" class="headerlink" title="g_main_loop_quit"></a>g_main_loop_quit</h2><p>简介：GLib的API，停止GMainLoop的运行。任何使用g_main_loop_run()开启的循环都将返回。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">g_main_loop_quit</span><span class="params">(GMainLoop* loop)</span></span></span><br></pre></td></tr></table></figure></div>

<h2 id="g-signal-connect"><a href="#g-signal-connect" class="headerlink" title="g_signal_connect"></a>g_signal_connect</h2><p>简介：GObject的宏，用于将信号处理器连接到特定对象的某个信号上。当一个信号被发出时，处理器将被同步调用。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> g_signal_connect(instance, detailed_signal, c_handler, data)</span></span><br></pre></td></tr></table></figure></div>


<h2 id="arv-stream-set-emit-signals"><a href="#arv-stream-set-emit-signals" class="headerlink" title="arv_stream_set_emit_signals"></a>arv_stream_set_emit_signals</h2><p>简介：控制流对象信号发射。默认情况下流对象发射信号是禁用的，因为信号发射在性能上有一定开销而且在某些应用场景下是不需要的。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">arv_stream_set_emit_signals</span><span class="params">(ArvStream* stream, gboolean emit_signals)</span></span></span><br></pre></td></tr></table></figure></div>
<p>Available since: 0.2.0</p>
<h1 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="回调函数的同步调用与异步调用"><a href="#回调函数的同步调用与异步调用" class="headerlink" title="回调函数的同步调用与异步调用"></a>回调函数的同步调用与异步调用</h2><p>观察程序运行时的日志，可以发现new_buffer_cb的运行并不是在主线程中。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/04/25/aravis-multiple-acquisition-signal/solution.png"
                     
                ></p>
<p>但是按照<code>g_signal_connect</code>的描述，回调函数应该是被同步调用，也就是说<code>new_buffer_cb</code>理论上应该在主线程被调用。<br>后来查看文档发现，在GObject的信号系统中，处理器的调用是同步的。当信号发射时，其关联的所有处理器会都会在发射信号的线程中按照它们被连接的顺序依次执行。</p>
<p>所以正确的应该是：处理器是在信号发射的线程被调用，而不是在处理器被注册时的线程。</p>
<p>在本例中，预定义的信号<code>new-buffer</code>的处理器<code>new_buffer_cb</code>被绑定在流对象上，这意味着每当流对象有一个新的buffer可用时，这个信号就会被发射，随后<code>new_buffer_cb</code>就被调用。而官方文档钟提到，流对象内部是使用一个单独的线程来监听数据的到达，因此信号是在这个单独的线程被发射的，也就是说回调函数也是在这个单独的线程被调用的，而不是在主线程中。</p>
<h2 id="帧丢失问题"><a href="#帧丢失问题" class="headerlink" title="帧丢失问题"></a>帧丢失问题</h2><p>官方给出的例程中，先启动的相机采集，然后才开始事件循环。我认为这样的话会存在丢帧的问题，因为在事件循环启动并准备好处理接收到的图像之前，相机可能已经开始发送数据，如果数据流的缓冲不足或处理不及时，新的图像数据可能会覆盖还未处理的旧数据，或者直接被丢弃。</p>
<p>所以我对代码做了一些改动，改变调用顺序为先开启事件循环，然后再启动相机的采集，代码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier:Unlicense */</span></span><br><span class="line"><span class="comment">/* Aravis header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arv.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Standard headers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LogManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	GMainLoop *main_loop;</span><br><span class="line">	guint32 counter;</span><br><span class="line">	ArvCamera *camera;</span><br><span class="line">&#125; AppData;</span><br><span class="line"></span><br><span class="line"><span class="function">gboolean <span class="title">start_acquisition_cb</span><span class="params">(gpointer user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AppData *app_data = <span class="built_in">static_cast</span>&lt;AppData*&gt;(user_data);</span><br><span class="line">    GError *error = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">arv_camera_start_acquisition</span>(app_data-&gt;camera, &amp;error);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, error-&gt;message);</span><br><span class="line">        <span class="built_in">g_main_loop_quit</span>(app_data-&gt;main_loop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只调用一次</span></span><br><span class="line">    <span class="keyword">return</span> FALSE; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AppData app_data;</span><br><span class="line">	GError *error = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	app_data.main_loop = <span class="built_in">g_main_loop_new</span> (<span class="literal">NULL</span>, FALSE);</span><br><span class="line">	app_data.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	app_data.camera = <span class="built_in">arv_camera_new</span> (<span class="literal">NULL</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ARV_IS_CAMERA</span> (app_data.camera)) &#123;</span><br><span class="line">		ArvStream *stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Found camera &#x27;%s&#x27;\n&quot;</span>, <span class="built_in">arv_camera_get_model_name</span> (app_data.camera, <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">arv_camera_set_acquisition_mode</span> (app_data.camera, ARV_ACQUISITION_MODE_CONTINUOUS, &amp;error);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">			stream = <span class="built_in">arv_camera_create_stream</span> (app_data.camera, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ARV_IS_STREAM</span> (stream)) &#123;</span><br><span class="line">			<span class="type">int</span> i;</span><br><span class="line">			<span class="type">size_t</span> payload;</span><br><span class="line"></span><br><span class="line">			payload = <span class="built_in">arv_camera_get_payload</span> (app_data.camera, &amp;error);</span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">					<span class="built_in">arv_stream_push_buffer</span> (stream, <span class="built_in">arv_buffer_new</span> (payload, <span class="literal">NULL</span>));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">g_signal_connect</span> (stream, <span class="string">&quot;new-buffer&quot;</span>, <span class="built_in">G_CALLBACK</span> (new_buffer_cb), &amp;app_data);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">PAW_INFO</span>(<span class="string">&quot;emit signals&quot;</span>);</span><br><span class="line">            <span class="built_in">arv_stream_set_emit_signals</span> (stream, TRUE);</span><br><span class="line">            <span class="built_in">PAW_INFO</span>(<span class="string">&quot;emit signals end&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* if (error == NULL)</span></span><br><span class="line"><span class="comment">				arv_camera_start_acquisition (camera, &amp;error); */</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//在主循环开始后尽快执行一次start_acquisition_cb</span></span><br><span class="line">			<span class="built_in">g_idle_add</span>(start_acquisition_cb, &amp;app_data);</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">PAW_INFO</span>(<span class="string">&quot;start main loop&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="built_in">g_main_loop_run</span> (app_data.main_loop);</span><br><span class="line">			<span class="built_in">PAW_INFO</span>(<span class="string">&quot;start main loop end&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (error == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="built_in">arv_camera_stop_acquisition</span> (app_data.camera, &amp;error);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">arv_stream_set_emit_signals</span> (stream, FALSE);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">g_clear_object</span> (&amp;stream);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">g_clear_object</span> (&amp;app_data.camera);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">g_main_loop_unref</span> (app_data.main_loop);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Error: %s\n&quot;</span>, error-&gt;message);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>工业相机</category>
        <category>Aravis</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>开源相机管理库Aravis学习——PixelFormat编码规则</title>
    <url>/2024/04/28/aravis-pixelformat/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18163483" >Aravis官方例程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的时候，有这么一个函数：<code>arv_camera_get_pixel_format</code>，它的返回类型是<code>ArvPixelFormat</code>(本质是个32位无符号整数)。这意味着对于每个图像数据格式，都有自己对应的唯一的编码。我比较好奇Aravis是通过什么规则对各种图像数据格式进行的编码，于是就查看了源码。</p>
<p>本文主要讨论Aravis中对不同图像数据格式的编码规则。</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="PixelFormat"><a href="#PixelFormat" class="headerlink" title="PixelFormat"></a>PixelFormat</h2><p>PixelFormat指的是图像中每个像素的数据格式，它定义了图像中像素的组成方式、颜色信息的存储方法和每个像素所占的位数等。这一格式对于图像的处理和显示是非常关键的，因为它直接影响到图像的质量和处理的效率。</p>
<p>常见的PixelFormat有：Mono8，BayerGB8，BayerGB10等。</p>
<h2 id="Bpp"><a href="#Bpp" class="headerlink" title="Bpp"></a>Bpp</h2><p>在工业相机中，<code>Bpp</code>通常指的是”bits per pixel”，它描述了存储每个像素所需的位数。这个值决定了图像的颜色深度以及可能包含的信息量。例如：</p>
<ul>
<li><strong>Bpp8</strong>: 每个像素使用8位表示，常用于灰度图像，可以显示256种灰度级别。</li>
<li><strong>Bpp16</strong>: 每个像素使用16位，可以是更深的灰度图，或者是用于存储彩色图像的颜色分量之一（如在某些彩色格式中，红色、绿色和蓝色每个分量可能各占16位）。</li>
<li><strong>Bpp24 或 Bpp32</strong>: 这通常用于彩色图像，其中每个颜色分量（红、绿、蓝）各占8位，32位图像格式可能会包含一个额外的8位用于透明度（alpha通道）。</li>
</ul>
<p>在工业成像应用中，Bpp的选择对于图像质量和处理效率非常重要，因为它直接影响图像的细节和色彩表达。高Bpp值允许图像包含更多的颜色和亮度级别，从而提供更精确的视觉数据，但也意味着更大的数据大小和处理需求。</p>
<h1 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>像素格式指定了图像中每个像素应该如何表示，包括每个像素的组件数量和每个组件的位数等。在Aravis中通过编码可以清晰的表示图像数据的颜色和位深信息，部分定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: arvenums.h</span></span><br><span class="line"><span class="comment">/* Grey pixel formats */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ARV_PIXEL_FORMAT_MONO_8			((ArvPixelFormat) 0x01080001u)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARV_PIXEL_FORMAT_BAYER_GR_8		((ArvPixelFormat) 0x01080008u)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Color pixel formats */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARV_PIXEL_FORMAT_RGB_8_PACKED		((ArvPixelFormat) 0x02180014u)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Custom */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARV_PIXEL_FORMAT_CUSTOM_BAYER_GR_12_PACKED  	((ArvPixelFormat) 0x810c0001u)</span></span><br></pre></td></tr></table></figure></div>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于每个PixelFormat，都有唯一一个32位的无符号整数与之对应。</p>
<p>以Mono8为例，其对应的32位无符号整数为：<code>0x01080001</code>，我们从高位向低位看：</p>
<ul>
<li><code>0x01</code>：对像素格式的一个分类，Aravis中共分为三类，对应的编号为<code>0x01</code>，<code>0x02</code>和<code>0x08</code>。具体的分类准则在后面讨论；</li>
<li><code>0x08</code>：表示当前PixelFormat对应的Bpp，<code>0x08</code>就对应Bpp8；</li>
<li><code>0x0001</code>：为像素格式设定的序号。</li>
</ul>
<h2 id="分类标准"><a href="#分类标准" class="headerlink" title="分类标准"></a>分类标准</h2><p>之前本来还想自己推断一下Aravis中对PixelFormat的分类依据，后来我查资料时看到了<a class="link"   href="https://www.emva.org/wp-content/uploads/GenICamPixelFormatValues.pdf" >GenICam Pixel Format Names and Values <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这应该是相当于EMVA规定的一个准则吧。对比源码可以发现，Aravis中<code>0x01</code>和<code>0x02</code>开头的PixelFormat对应的值就是遵循的这个文件的内容。</p>
<p><code>0x01</code>和<code>0x02</code>的差别估计就是一个像素点对应的通道数量不同，<code>0x01</code>表示一个像素点上只有一个通道，<code>0x02</code>表示一个像素点上的通道数大于1。至于<code>0x08</code>，应该是Aravis自己定义的一些格式，具体的作用目前不太清楚。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="ARV-PIXEL-FORMAT-BIT-PER-PIXEL"><a href="#ARV-PIXEL-FORMAT-BIT-PER-PIXEL" class="headerlink" title="ARV_PIXEL_FORMAT_BIT_PER_PIXEL"></a>ARV_PIXEL_FORMAT_BIT_PER_PIXEL</h2><p>在arvenums.h中还定义了一个宏，用于获取像素格式的Bpp：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARV_PIXEL_FORMAT_BIT_PER_PIXEL(pixel_format) (((pixel_format) &gt;&gt; 16) &amp; 0xff)</span></span><br></pre></td></tr></table></figure></div>
<p>以Mono8为例，其值为0x01080001，右移16位并与上<code>0xff</code>，获取到第17位到32位：<code>0x08</code>。对应的Bpp就可以被正确解析出来，为8。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a class="link"   href="https://www.emva.org/wp-content/uploads/GenICam_SFNC_v2_5.pdf" >GenICam_SFNC_v2_5 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>2.<a class="link"   href="https://www.emva.org/wp-content/uploads/GenICam_PFNC_2_4.pdf" >GenICam_PFNC_v2_4 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>3.<a class="link"   href="https://www.emva.org/wp-content/uploads/GenICamPixelFormatValues.pdf" >GenICam Pixel Format Names and Values <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>工业相机</category>
        <category>Aravis</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>开源相机管理库Aravis例程学习（一）——单帧采集single-acquisition</title>
    <url>/2024/04/10/aravis-single-acquisition/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文针对<a class="link"   href="https://github.com/AravisProject/aravis-c-examples" >官方例程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中的第一个例程：single-acquisition做简单的讲解，并简单分析其中调用的<code>arv_camera_new </code>，<code>arv_camera_acquisition</code>，<code>arv_camera_get_model_name </code>，<code>arv_buffer_get_image_width </code>，<code>arv_buffer_get_image_height </code>函数。</p>
<p>aravis版本：0.8.31<br>操作系统：ubuntu-20.04<br>gcc版本：9.4.0</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier:Unlicense */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Aravis header */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Standard headers */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Connect to the first available camera, then acquire a single buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ArvCamera *camera;</span><br><span class="line">	ArvBuffer *buffer;</span><br><span class="line">	GError *error = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Connect to the first available camera */</span></span><br><span class="line">	camera = <span class="built_in">arv_camera_new</span> (<span class="literal">NULL</span>, &amp;error);</span><br><span class="line">    <span class="comment">//camera = arv_camera_new (&quot;192.168.6.23&quot;, &amp;error);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ARV_IS_CAMERA</span> (camera)) &#123;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Found camera &#x27;%s&#x27;\n&quot;</span>, <span class="built_in">arv_camera_get_model_name</span> (camera, <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Acquire a single buffer */</span></span><br><span class="line">		buffer = <span class="built_in">arv_camera_acquisition</span> (camera, <span class="number">0</span>, &amp;error);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ARV_IS_BUFFER</span> (buffer)) &#123;</span><br><span class="line">			<span class="comment">/* Display some informations about the retrieved buffer */</span></span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;Acquired %d×%d buffer\n&quot;</span>,</span><br><span class="line">				<span class="built_in">arv_buffer_get_image_width</span> (buffer),</span><br><span class="line">				<span class="built_in">arv_buffer_get_image_height</span> (buffer));</span><br><span class="line">			<span class="comment">/* Destroy the buffer */</span></span><br><span class="line">			<span class="built_in">g_clear_object</span> (&amp;buffer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Destroy the camera instance */</span></span><br><span class="line">		<span class="built_in">g_clear_object</span> (&amp;camera);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* An error happened, display the correspdonding message */</span></span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Error: %s\n&quot;</span>, error-&gt;message);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>此例程较为简单，每一步的细节查看注释即可，此处不过多讲解。<br>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/04/10/aravis-single-acquisition/result.png"
                     
                ></p>
<h1 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h1><h2 id="arv-camera-new"><a href="#arv-camera-new" class="headerlink" title="arv_camera_new"></a>arv_camera_new</h2><p>简介：创建一个ArvCamera对象，如果name是NULL，则连接第一个可用的相机。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ArvCamera* <span class="title">arv_camera_new</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* name, GError** error)</span></span></span><br></pre></td></tr></table></figure></div>
<p>如果是Gige相机，name的格式可以是：</p>
<ul>
<li><code>&lt;vendor&gt;-&lt;model&gt;-&lt;serial&gt;</code></li>
<li><code>&lt;vendor_alias&gt;-&lt;serial&gt;</code></li>
<li><code>&lt;vendor&gt;-&lt;serial&gt;</code></li>
<li><code>&lt;user_id&gt;</code></li>
<li><code>&lt;ip_address&gt;</code></li>
<li><code>&lt;mac_address&gt;</code></li>
</ul>
<p>例如：</p>
<ul>
<li>The Imaging Source Europe GmbH-DFK 33GX265-39020369</li>
<li>The Imaging Source Europe GmbH-39020369</li>
<li>TIS-39020369</li>
<li>192.168.0.2</li>
<li>00:07:48:af:a2:61</li>
</ul>
<p>Available since 0.8.0</p>
<h2 id="arv-camera-acquisition"><a href="#arv-camera-acquisition" class="headerlink" title="arv_camera_acquisition"></a>arv_camera_acquisition</h2><p>简介：获取一帧图像。<br>注意：①本函数会将相机设置为单帧采集模式②返回的buffer最终必须要通过g_object_unref()释放</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ArvBuffer* <span class="title">arv_camera_acquisition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	ArvCamera* camera,         </span></span></span><br><span class="line"><span class="params"><span class="function">	guint64 timeout,     <span class="comment">//采集超时时间，单位µs</span></span></span></span><br><span class="line"><span class="params"><span class="function">	GError** error)</span></span></span><br></pre></td></tr></table></figure></div>
<p>Available since: 0.8.0</p>
<h2 id="arv-camera-get-model-name"><a href="#arv-camera-get-model-name" class="headerlink" title="arv_camera_get_model_name"></a>arv_camera_get_model_name</h2><p>简介：获取相机型号名称</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">arv_camera_get_model_name</span> <span class="params">(ArvCamera* camera, GError** error)</span></span></span><br></pre></td></tr></table></figure></div>
<p>Available since 0.8.0</p>
<h2 id="arv-buffer-get-image-width"><a href="#arv-buffer-get-image-width" class="headerlink" title="arv_buffer_get_image_width"></a>arv_buffer_get_image_width</h2><p>简介：获取图片的width<br>注意：此函数只能在buffer payload为<code>ARV_BUFFER_PAYLOAD_TYPE_IMAGE</code>、<code>ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA</code>或<code>ARV_BUFFER_PAYLOAD_TYPE_MULTIPART</code>时使用</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">gint <span class="title">arv_buffer_get_image_width</span><span class="params">(ArvBuffer* buffer)</span></span></span><br></pre></td></tr></table></figure></div>
<p>Available since: 0.4.0</p>
<h2 id="arv-buffer-get-image-height"><a href="#arv-buffer-get-image-height" class="headerlink" title="arv_buffer_get_image_height"></a>arv_buffer_get_image_height</h2><p>简介：获取图片的height<br>注意：此函数只能在buffer payload为<code>ARV_BUFFER_PAYLOAD_TYPE_IMAGE</code>、<code>ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA</code>或<code>ARV_BUFFER_PAYLOAD_TYPE_MULTIPART</code>时使用</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">gint <span class="title">arv_buffer_get_image_height</span><span class="params">(ArvBuffer* buffer)</span></span></span><br></pre></td></tr></table></figure></div>
<p>Available since: 0.4.0</p>
]]></content>
      <categories>
        <category>工业相机</category>
        <category>Aravis</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>C++自用小轮子——单例模板</title>
    <url>/2024/04/03/cpp-development-components-singleton-CRTP/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>记录开发时自用的小轮子：单例模板。</p>
<h1 id="单例模板"><a href="#单例模板" class="headerlink" title="单例模板"></a>单例模板</h1><p>提供了一个基于模板的单例模式的实现，代码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T&amp; <span class="title">GetInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> T instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CSingleton</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">    CSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SINGLETON_H</span></span></span><br></pre></td></tr></table></figure></div>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>使用了奇异递归模板模式（Curiously Recurring Template Pattern, CRTP）。子类将自己作为模板参数传递给单例模板进行模板实例化，用做基类；同时在子类内部将基类声明为友元，这样才能在通过CSingleton<T>::getInstance()方法创建CLogManager唯一实例时，调用到CLogManager的私有的构造函数。<br>如此操作就可以使业务类（以CLogManager为例）具有单例属性，代码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLogManager</span> <span class="keyword">final</span> : <span class="keyword">public</span> CSingleton&lt;CLogManager&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CSingleton</span>&lt;CLogManager&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="built_in">CLogManager</span>();</span><br><span class="line">     ~<span class="built_in">CLogManager</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CLOGMANAGER_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLogManager&amp; p_log_instance = CLogManager::<span class="built_in">GetInstance</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++小轮子</category>
      </categories>
  </entry>
  <entry>
    <title>C++自用小轮子——线程安全队列</title>
    <url>/2024/04/03/cpp-development-components-threadsafe-queue/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>记录开发时自用的小轮子：线程安全队列</p>
<h1 id="线程安全队列"><a href="#线程安全队列" class="headerlink" title="线程安全队列"></a>线程安全队列</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADSAFEQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADSAFEQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadSafeQueue</span>();</span><br><span class="line">    <span class="built_in">ThreadSafeQueue</span>(<span class="type">const</span> ThreadSafeQueue&amp; other);</span><br><span class="line">    ThreadSafeQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadSafeQueue&amp; other);</span><br><span class="line">    ~<span class="built_in">ThreadSafeQueue</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于pop方法，std::queue中的pop只负责弹出元素，不返回元素</span></span><br><span class="line">    <span class="comment">//这里为了接口简化，设计为在pop的同时返回弹出的元素</span></span><br><span class="line">    <span class="comment">//timeout为超时时间，单位为毫秒</span></span><br><span class="line">    <span class="comment">//默认阻塞pop</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value, std::chrono::milliseconds timeout_millisecond = std::chrono::milliseconds::max())</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">(std::chrono::milliseconds timeout_millisecond = std::chrono::milliseconds::max())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">front_ptr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mtx_;</span><br><span class="line">    std::queue&lt;T&gt; data_queue_;</span><br><span class="line">    std::condition_variable cv_data_; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ThreadSafeQueue&lt;T&gt;::<span class="built_in">ThreadSafeQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ThreadSafeQueue&lt;T&gt;::~<span class="built_in">ThreadSafeQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ThreadSafeQueue&lt;T&gt;::<span class="built_in">ThreadSafeQueue</span>(<span class="type">const</span> ThreadSafeQueue&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.mtx_)</span></span>;</span><br><span class="line">    data_queue_ = other.data_queue_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ThreadSafeQueue&lt;T&gt;&amp; ThreadSafeQueue&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> ThreadSafeQueue&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同时锁定两个互斥量，防止死锁</span></span><br><span class="line">    std::<span class="built_in">lock</span>(mtx_, other.mtx_);</span><br><span class="line">    <span class="comment">//领养锁，因为已经锁定了</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">self_lock</span><span class="params">(mtx_, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">other_lock</span><span class="params">(other.mtx_, std::adopt_lock)</span></span>;</span><br><span class="line">    data_queue_ = other.data_queue_;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ThreadSafeQueue&lt;T&gt;::<span class="built_in">push</span>(T new_value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    data_queue_.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">    cv_data_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> ThreadSafeQueue&lt;T&gt;::<span class="built_in">wait_and_pop</span>(T&amp; value, std::chrono::milliseconds timeout_millisecond)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (data_queue_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout_millisecond == std::chrono::milliseconds::<span class="built_in">max</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cv_data_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue_.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cv_data_.<span class="built_in">wait_for</span>(lock, timeout_millisecond, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue_.<span class="built_in">empty</span>();&#125;))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    value = std::<span class="built_in">move</span>(data_queue_.<span class="built_in">front</span>());</span><br><span class="line">    data_queue_.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; ThreadSafeQueue&lt;T&gt;::<span class="built_in">wait_and_pop</span>(std::chrono::milliseconds timeout_millisecond)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (data_queue_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout_millisecond == std::chrono::milliseconds::<span class="built_in">max</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cv_data_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue_.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(cv_data_.<span class="built_in">wait_for</span>(lock, timeout_millisecond, [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> !data_queue_.<span class="built_in">empty</span>();&#125;)))</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::move(data_queue_.front())))</span></span>;</span><br><span class="line">    data_queue_.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> ThreadSafeQueue&lt;T&gt;::<span class="built_in">empty</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue_.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> ThreadSafeQueue&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; ThreadSafeQueue&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue_.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> data_queue_.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T&amp; ThreadSafeQueue&lt;T&gt;::<span class="built_in">front</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue_.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> data_queue_.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; ThreadSafeQueue&lt;T&gt;::<span class="built_in">front_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue_.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;T&gt;(data_queue_.<span class="built_in">front</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// THREADSAFEQUEUE_H</span></span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++小轮子</category>
      </categories>
  </entry>
  <entry>
    <title>编译期链接时共享库路径搜索优先级实验</title>
    <url>/2024/07/29/cpp-shared-lib-search-priority-test-linking/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a class="link"   href="https://www.cnblogs.com/paw5zx/p/18302745" >《共享库链接和加载时的路径搜索优先级》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中提到，使用g++时，共享库在编译期链接时的库路径搜索优先级为：<code>-L指定的路径</code>&gt;<code>LIBRARY_PATH记录的路径</code>&gt;<code>默认路径</code>。</p>
<p>本实验分三步验证上述结论<br>①单独测试每种方法指定的路径的可行性<br>②对比测试三种方法间的优先级<br>③使用DEBUG模式，查看链接器输出的详细信息，二次验证上述结论</p>
<p>值得注意的是，我看网上都说<code>LIBRARY_PATH指定的路径</code>优先级要大于<code>默认路径</code>的优先级，但是就我的测试结果来看，结论是相反的（可能是我使用了g++而不是直接使用底层的ld?）。</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>操作系统：<code>Ubuntu 20.04</code><br>编译器：<code>g++-11.4.0</code><br>make：<code>GNU Make 4.2.1</code></p>
<h1 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h1><p>项目的目录结构如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── lib</span><br><span class="line">├── obj</span><br><span class="line">├── libhello.cpp</span><br><span class="line">├── libhello_alt.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">└── makefile</span><br></pre></td></tr></table></figure></div>
<p>其中：</p>
<ul>
<li><code>lib</code>为存放共享库的文件夹</li>
<li><code>obj</code>为存放可重定位目标文件的文件夹</li>
<li><code>libhello.cpp</code>和<code>libhello_alt.cpp</code>为共享库源码（用于模拟不同版本的共享库），他们中都只有一个hello函数，两个hello函数的函数签名完全相同。其中<code>libhello.cpp</code>将被编译为<code>libhello.so.1.1.0</code>（soname为<code>libhello.so.1</code>），<code>libhello_alt.cpp</code>将被编译为<code>libhello.so.2.1.0</code>（soname为<code>libhello.so.2</code>）</li>
<li><code>mian.cpp</code>为主函数，其中调用了hello函数</li>
<li><code>makefile</code>为自动化构建脚本</li>
</ul>
<p>在附录中，我将提供本次实验涉及到的代码。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在终端中进入项目路径，并输入<code>make</code>，会在<code>./lib</code>下生成<code>libhello.so.1.1.0</code>与<code>libhello.so.2.1.0</code>，在<code>./obj</code>下生成<code>main.o</code>。<br>生成后项目的目录结构如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── lib</span><br><span class="line">│   ├── libhello.so.1.1.0	</span><br><span class="line">│   └── libhello.so.2.1.0</span><br><span class="line">├── obj</span><br><span class="line">│   └── main.o</span><br><span class="line">├── libhello.cpp</span><br><span class="line">├── libhello_alt.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">└── makefile</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h1 id="单独测试"><a href="#单独测试" class="headerlink" title="单独测试"></a>单独测试</h1><h2 id="不配置路径"><a href="#不配置路径" class="headerlink" title="不配置路径"></a>不配置路径</h2><p>不做任何路径的配置并且不在默认路径下放置<code>libhello.so</code>文件，查看是否可以将<code>main.o</code>和<code>hello</code>的共享库文件链接成功。</p>
<p>直接使用makefile中预设好的命令即可完成上述操作：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">make main_none</span><br></pre></td></tr></table></figure></div>

<p>输出：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/1_none.png"
                     
                ></p>
<p>可以看到由于我们没有配置任何额外的搜索路径，并且没有在默认搜索路径下放置<code>libhello.so</code>文件，链接器就找不到相应的共享库文件，就会链接失败。</p>
<p><strong>单次实验结束后，使用<code>make clean</code>命令清除本次实验生成的文件，然后再次使用<code>make</code>命令重新生成共享库文件和可重定位目标文件。（每次做完一个小实验，都要重复此步骤，后不赘述）</strong></p>
<h2 id="默认路径"><a href="#默认路径" class="headerlink" title="默认路径"></a>默认路径</h2><p>将<code>libhello.so.1.1.0</code>拷贝至默认搜索路径<code>/usr/lib</code>，并在<code>/usr/lib</code>下创建一个软链接（<code>libhello.so</code>）指向它，然后进行链接操作，查看是否可以将<code>main.o</code>和<code>hello</code>的共享库文件链接成功。</p>
<p>直接使用makefile中预设好的命令即可完成上述操作：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make main_default</span><br></pre></td></tr></table></figure></div>

<p>输出：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/2_default_result.png"
                     
                ></p>
<p>没有报错。</p>
<p>然后使用<code>readelf -d</code>查看可执行文件的动态段信息，可见链接成功，共享库的soname已经被写入到可执行文件的动态段信息中了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/3_default_readelf.png"
                     
                ></p>
<h2 id="LIBRARY-PATH"><a href="#LIBRARY-PATH" class="headerlink" title="LIBRARY_PATH"></a>LIBRARY_PATH</h2><p>创建路径<code>/opt/hellolib</code>，将<code>libhello.so.1.1.0</code>拷贝至<code>/opt/hellolib</code>，并在<code>/opt/hellolib</code>下创建一个软链接（<code>libhello.so</code>）指向它。然后将<code>/opt/hellolib</code>添加至<code>LIBRARY_PATH</code>并进行<code>main.o</code>和<code>hello</code>的共享库文件的链接操作，查看是否可以链接成功。</p>
<p>直接使用makefile中预设好的命令即可完成上述操作：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make main_library_path</span><br></pre></td></tr></table></figure></div>

<p>输出：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/4_libpath_result.png"
                     
                ></p>
<p>没有报错。</p>
<p>然后使用<code>readelf -d</code>查看可执行文件的动态段信息，可见链接成功，共享库的soname已经被写入到可执行文件的动态段信息中了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/5_libpath_readelf.png"
                     
                ></p>
<h2 id="L"><a href="#L" class="headerlink" title="-L"></a>-L</h2><p>创建路径<code>/opt/hellolib</code>，将<code>libhello.so.1.1.0</code>拷贝至<code>/opt/hellolib</code>，并在<code>/opt/hellolib</code>下创建一个软链接（<code>libhello.so</code>）指向它，然后添加链接选项<code>-L/opt/hellolib</code>并进行链接操作，查看是否可以将<code>main.o</code>和<code>hello</code>的共享库文件链接成功。</p>
<p>直接使用makefile中预设好的命令即可完成上述操作：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make main_l</span><br></pre></td></tr></table></figure></div>

<p>输出：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/6_l_result.png"
                     
                ></p>
<p>没有报错。</p>
<p>然后使用<code>readelf -d</code>查看可执行文件的动态段信息，可见链接成功，共享库的soname已经被写入到可执行文件的动态段信息中了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/7_l_readelf.png"
                     
                ></p>
<h1 id="优先级测试"><a href="#优先级测试" class="headerlink" title="优先级测试"></a>优先级测试</h1><h2 id="默认路径和LIBRARY-PATH"><a href="#默认路径和LIBRARY-PATH" class="headerlink" title="默认路径和LIBRARY_PATH"></a>默认路径和LIBRARY_PATH</h2><ul>
<li>①将<code>libhello.so.2.1.0</code>拷贝至默认搜索路径<code>/usr/lib</code>，并在<code>/usr/lib</code>下创建一个软链接（<code>libhello.so</code>）指向它。</li>
<li>②创建路径<code>/opt/hellolib</code>，将<code>libhello.so.1.1.0</code>拷贝至<code>/opt/hellolib</code>，并在<code>/opt/hellolib</code>下创建一个软链接（<code>libhello.so</code>）指向它。</li>
<li>③将<code>/opt/hellolib</code>添加至<code>LIBRARY_PATH</code>并进行<code>main.o</code>和<code>hello</code>的共享库文件的链接操作。</li>
</ul>
<p>直接使用makefile中预设好的命令即可完成上述操作：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make cmp_default_libpath</span><br></pre></td></tr></table></figure></div>

<p>输出：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/8_default_libpath_result.png"
                     
                ></p>
<p>然后使用<code>readelf -d</code>查看可执行文件的动态段信息，可见链接成功，并且链接的是默认路径下的共享库文件<code>libhello.so.2.1.0</code>（其soname为<code>libhello.so.2</code>）。因此可以得出结论：<code>默认路径</code>搜索优先级要高于<code>LIBRARY_PATH指定的路径</code>的搜索优先级。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/9_default_libpath_readelf.png"
                     
                ></p>
<p>对于上述结论，将会在后文的DEBUG模式中给出更详细的验证。</p>
<h2 id="L和默认路径"><a href="#L和默认路径" class="headerlink" title="-L和默认路径"></a>-L和默认路径</h2><ul>
<li>①创建路径<code>/opt/hellolib</code>，将<code>libhello.so.2.1.0</code>拷贝至<code>/opt/hellolib</code>，并在<code>/opt/hellolib</code>下创建一个软链接（<code>libhello.so</code>）指向它。</li>
<li>②将<code>libhello.so.1.1.0</code>拷贝至默认搜索路径<code>/usr/lib</code>，并在<code>/usr/lib</code>下创建一个软链接（<code>libhello.so</code>）指向它。</li>
<li>③添加链接选项<code>-L/opt/hellolib</code>并进行<code>main.o</code>和<code>hello</code>的共享库文件的链接操作。</li>
</ul>
<p>直接使用makefile中预设好的命令即可完成上述操作：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make cmp_l_default</span><br></pre></td></tr></table></figure></div>

<p>输出：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/10_l_default_result.png"
                     
                ></p>
<p>然后使用<code>readelf -d</code>查看可执行文件的动态段信息，可见链接成功，并且链接的是-L指定路径下的共享库文件<code>libhello.so.2.1.0</code>（其soname为<code>libhello.so.2</code>）。因此可以得出结论：<code>-L指定路径</code>搜索优先级要高于<code>默认搜索路径</code>的搜索优先级。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/11_l_default_readelf.png"
                     
                ></p>
<p>对于上述结论，将会在后文的DEBUG模式中给出更详细的验证。</p>
<h1 id="DEBUG模式"><a href="#DEBUG模式" class="headerlink" title="DEBUG模式"></a>DEBUG模式</h1><p>在makefile中我添加了一个用于对比三种路径优先级的目标<code>cmp_all</code>，其中</p>
<ul>
<li>-L指定路径为<code>/opt/hellolib_L</code></li>
<li>默认路径为<code>/usr/lib</code></li>
<li>LIBRARY_PATH指定路径为<code>/opt/hellolib</code>，<code>.so</code>文件（<code>libhello.so.1.1.0</code>的软链接）仅放置于此路径下。</li>
</ul>
<p>此外我还预设了一个DEBUG模式，开启DEBUG模式可以查看编译过程的详细信息，开启的方法就是在命令后面添加<code>DEBUG_MODE=1</code>，例如：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make cmp_all DEBUG_MODE=1</span><br></pre></td></tr></table></figure></div>

<p>下面我们就使用DEBUG模式运行<code>cmp_all</code>查看其输出（输出信息很多，我截取关键部分讲解）：</p>
<h2 id="编译器配置详细信息"><a href="#编译器配置详细信息" class="headerlink" title="编译器配置详细信息"></a>编译器配置详细信息</h2><p>我们先看一下gcc在编译过程中输出的编译器配置详细信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/12_debug_compiler_info.png"
                     
                ></p>
<p>图片中的文字内容如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">LIBRARY_PATH=</span><br><span class="line">	/usr/lib/gcc/x86_64-linux-gnu/11/:</span><br><span class="line">	/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/:</span><br><span class="line">	/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/:</span><br><span class="line">	/lib/x86_64-linux-gnu/:</span><br><span class="line">	/lib/../lib/:</span><br><span class="line">	/usr/lib/x86_64-linux-gnu/:</span><br><span class="line">	/usr/lib/../lib/:</span><br><span class="line">	/opt/hellolib/:</span><br><span class="line">	/usr/lib/gcc/x86_64-linux-gnu/11/../../../:</span><br><span class="line">	/lib/:</span><br><span class="line">	/usr/lib/</span><br></pre></td></tr></table></figure></div>
<p>我们可以发现编译器列出了系统环境变量LIBRARY_PATH的内容，包含：</p>
<ul>
<li>①我们向环境变量添加的<code>/opt/hellolib/</code>，其所处位置应该是由编译器规定的</li>
<li>②系统默认的库路径（<code>/usr/lib</code>和<code>/lib</code>），位于最后</li>
<li>③根据编译器配置自动添加的路径，如<code>/usr/lib/gcc/x86_64-linux-gnu/11/</code>等</li>
</ul>
<p>然后再往下看，<code>COLLECT_GCC_OPTIONS</code>列出了传递给g++的一些选项：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/13_deliver.png"
                     
                ></p>
<p>图片中的文字内容如下（省略了一部分不需要关注的）：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">COLLECT_GCC_OPTIONS=...</span><br><span class="line">	-L/opt/hellolib_L</span><br><span class="line">	-L/usr/lib/gcc/x86_64-linux-gnu/11 </span><br><span class="line">	-L/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu </span><br><span class="line">	-L/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib </span><br><span class="line">	-L/lib/x86_64-linux-gnu </span><br><span class="line">	-L/lib/../lib </span><br><span class="line">	-L/usr/lib/x86_64-linux-gnu </span><br><span class="line">	-L/usr/lib/../lib </span><br><span class="line">	-L/opt/hellolib </span><br><span class="line">	-L/usr/lib/gcc/x86_64-linux-gnu/11/../../.. </span><br><span class="line">	...</span><br></pre></td></tr></table></figure></div>
<p>可以发现：</p>
<ul>
<li>①我们通过<code>-L</code>显式添加的路径<code>/opt/hellolib_L</code>被排在了最前面</li>
<li>②<code>LIBRARY_PATH</code>中的路径（除了<code>/usr/lib/</code>和<code>/lib/</code>，原因暂时未知），都被加上<code>-L</code>并传给了<code>COLLECT_GCC_OPTIONS</code>，并排在<code>/opt/hellolib_L</code>之后。</li>
</ul>
<h2 id="链接器详细信息"><a href="#链接器详细信息" class="headerlink" title="链接器详细信息"></a>链接器详细信息</h2><p>然后我们再看链接器输出的详细信息：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/14_debug_linker_info.png"
                     
                ></p>
<p>图片中的文字内容如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">SEARCH_DIR(<span class="string">&quot;=/usr/local/lib/x86_64-linux-gnu&quot;</span>); </span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/lib/x86_64-linux-gnu&quot;</span>); </span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/usr/lib/x86_64-linux-gnu&quot;</span>); </span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/usr/lib/x86_64-linux-gnu64&quot;</span>); </span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/usr/local/lib64&quot;</span>); </span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/lib64&quot;</span>); </span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/usr/lib64&quot;</span>); </span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/usr/local/lib&quot;</span>); </span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/lib&quot;</span>); </span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/usr/lib&quot;</span>); </span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/usr/x86_64-linux-gnu/lib64&quot;</span>); </span><br><span class="line">SEARCH_DIR(<span class="string">&quot;=/usr/x86_64-linux-gnu/lib&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p><code>SEARCH_DIR</code>指令是用来指定链接器在搜索动态和静态库文件时应当考虑的目录，这些路径通常包括系统的标准库目录，如<code>/usr/lib</code>和<code>/lib</code>等。但是注意，通过<code>-L</code>指定的路径会在运行时临时添加到<code>SEARCH_DIR</code>列表的前面，即<code>-L</code>指定的路径搜索优先级更高。</p>
<h2 id="DEBUG总结"><a href="#DEBUG总结" class="headerlink" title="DEBUG总结"></a>DEBUG总结</h2><p>至此，我们可以简单总结一下上述信息：</p>
<ul>
<li>我们设置的LIBRARY_PATH的值会传给编译器</li>
<li>编译器根据自己的配置以及我们手动赋予的LIBRARY_PATH变量的值，生成一个新的LIBRARY_PATH（我们手动赋予的LIBRARY_PATH变量的值处于一个特定的位置），并将这个新的LIBRARY_PATH的值(除了<code>/usr/lib</code>和<code>/lib</code>)加上<code>-L</code>传递给编译器</li>
<li>我们显式使用<code>-L</code>指定的路径也被传递给编译器，并位于所有<code>-L</code>选项的最前面</li>
</ul>
<p>而且对于编译器配置的路径，如<code>/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/</code>，其本质就是<code>/usr/lib/</code>（这也是<code>默认路径</code>优先级大于<code>LIBRARY_PATH指定路径</code>优先级的原因）。</p>
<p>因此对于<code>-L指定路径</code>，<code>LIBRARY_PATH指定路径</code>和<code>默认路径</code>，最终都被转化为<code>-L</code>的形式传递给编译器，且他们排列优先级为：</p>
<blockquote>
<p><code>-L指定路径</code>&gt;<code>默认路径</code>&gt;<code>LIBRARY_PATH指定路径</code></p>
</blockquote>
<p>因此他们的搜索优先级也是符合上述排列。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>最后我们可以通过链接器在链接特定库（比如我们的<code>libhello</code>）时的搜索过程验证上述结论：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/cpp-shared-lib-search-priority-test-linking/15_result.png"
                     
                ></p>
<p>可见链接器先是搜索我们使用<code>-L</code>指定的路径<code>/opt/hellolib_L</code>，然后搜索编译器配置的路径<code>/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/</code>（其本质就是默认路径<code>/usr/lib/</code>），最后搜索LIBRARY_PATH指定的路径<code>/opt/hellolib</code>。证明了编译过程中链接时库搜索路径的优先级为</p>
<blockquote>
<p>-L指定路径&gt;默认路径&gt;LIBRARY_PATH指定路径</p>
</blockquote>
<h1 id="默认路径-LIBRARY-PATH原因"><a href="#默认路径-LIBRARY-PATH原因" class="headerlink" title="默认路径&gt;LIBRARY_PATH原因"></a>默认路径&gt;LIBRARY_PATH原因</h1><p>如上文所述，g++根据自己的配置将例如：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/</span><br></pre></td></tr></table></figure></div>
<p>的路径添加到了LIBRARY_PATH中，而且位于用户设置的LIBRARY_PATH之前。这个路径的本质就是<code>/usr/lib/</code>。这就导致最终出现默认路径搜索优先级大于LIBRARY_PATH指定路径的搜索优先级的现象。</p>
<p>至于手动使用<code>ld</code>去链接<code>.o</code>和<code>.so</code>文件，后面有机会再做测试。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>死记优先级没必要，因为实际情况中还会遇到很多其他的规则。知道如何去看链接器的链接过程（如路径搜索顺序）才是排查问题的关键。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="库文件源码"><a href="#库文件源码" class="headerlink" title="库文件源码"></a>库文件源码</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: libhello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from the 1.1.0 library!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: libhello_alt.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from the 2.1.0 library!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="主程序源码"><a href="#主程序源码" class="headerlink" title="主程序源码"></a>主程序源码</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file: makefile</span></span><br><span class="line">CXX = g++</span><br><span class="line">CXXFLAGS = -fPIC</span><br><span class="line">LDFLAGS = -shared</span><br><span class="line">DEBUG_MODE ?= 0</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG_MODE)</span>,1)</span><br><span class="line">    DEBUG_OPTS = -v -Wl,--verbose</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: lib/libhello.so.1.1.0 lib/libhello.so.2.1.0 obj/main.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">lib/libhello.so.1.1.0: libhello.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> <span class="variable">$(LDFLAGS)</span> -Wl,-soname,libhello.so.1</span><br><span class="line"></span><br><span class="line"><span class="section">lib/libhello.so.2.1.0: libhello_alt.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> <span class="variable">$(LDFLAGS)</span> -Wl,-soname,libhello.so.2</span><br><span class="line"></span><br><span class="line"><span class="section">obj/main.o: main.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在任何路径下都无法搜索到libhello.so</span></span><br><span class="line"><span class="section">main_none: obj/main.o</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(DEBUG_OPTS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -lhello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试默认路径/usr/lib </span></span><br><span class="line"><span class="section">main_default: obj/main.o</span></span><br><span class="line">	cp ./lib/libhello.so.1.1.0 /usr/lib</span><br><span class="line">	ln -sf /usr/lib/libhello.so.1.1.0 /usr/lib/libhello.so</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(DEBUG_OPTS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -lhello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试仅使用LIBRARY_PATH</span></span><br><span class="line"><span class="section">main_library_path: obj/main.o</span></span><br><span class="line">	mkdir -p /opt/hellolib</span><br><span class="line">	cp ./lib/libhello.so.1.1.0 /opt/hellolib</span><br><span class="line">	ln -sf /opt/hellolib/libhello.so.1.1.0 /opt/hellolib/libhello.so</span><br><span class="line">	LIBRARY_PATH=/opt/hellolib <span class="variable">$(CXX)</span> <span class="variable">$(DEBUG_OPTS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -lhello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试仅使用-L</span></span><br><span class="line"><span class="section">main_l: obj/main.o</span></span><br><span class="line">	mkdir -p /opt/hellolib</span><br><span class="line">	cp ./lib/libhello.so.1.1.0 /opt/hellolib</span><br><span class="line">	ln -sf /opt/hellolib/libhello.so.1.1.0 /opt/hellolib/libhello.so</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(DEBUG_OPTS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -L/opt/hellolib -lhello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较默认路径和LIBRARY_PATH的搜索优先级</span></span><br><span class="line"><span class="section">cmp_default_libpath: obj/main.o</span></span><br><span class="line">	cp ./lib/libhello.so.2.1.0 /usr/lib</span><br><span class="line">	ln -sf /usr/lib/libhello.so.2.1.0 /usr/lib/libhello.so</span><br><span class="line">	mkdir -p /opt/hellolib</span><br><span class="line">	cp ./lib/libhello.so.1.1.0 /opt/hellolib</span><br><span class="line">	ln -sf /opt/hellolib/libhello.so.1.1.0 /opt/hellolib/libhello.so</span><br><span class="line">	LIBRARY_PATH=/opt/hellolib <span class="variable">$(CXX)</span> <span class="variable">$(DEBUG_OPTS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -lhello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较-L和默认路径的优先级</span></span><br><span class="line"><span class="section">cmp_l_default: obj/main.o</span></span><br><span class="line">	mkdir -p /opt/hellolib</span><br><span class="line">	cp ./lib/libhello.so.2.1.0 /opt/hellolib</span><br><span class="line">	ln -sf /opt/hellolib/libhello.so.2.1.0 /opt/hellolib/libhello.so</span><br><span class="line">	cp ./lib/libhello.so.1.1.0 /usr/lib</span><br><span class="line">	ln -sf /usr/lib/libhello.so.1.1.0 /usr/lib/libhello.so</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(DEBUG_OPTS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -L/opt/hellolib -lhello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总体比较测试，集合了-L，LIBRARY_PATH和默认路径</span></span><br><span class="line"><span class="section">cmp_all: main.cpp</span></span><br><span class="line">	mkdir -p /opt/hellolib</span><br><span class="line">	mkdir -p /opt/hellolib_L</span><br><span class="line">	cp ./lib/libhello.so.1.1.0 /opt/hellolib</span><br><span class="line">	ln -sf /opt/hellolib/libhello.so.1.1.0 /opt/hellolib/libhello.so</span><br><span class="line">	LIBRARY_PATH=/opt/hellolib <span class="variable">$(CXX)</span> <span class="variable">$(DEBUG_OPTS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -L/opt/hellolib_L -lhello</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f ./lib/* ./obj/* main_* cmp_*</span><br><span class="line">	rm -f /usr/lib/libhello.so*</span><br><span class="line">	rm -rf /opt/hellolib*</span><br><span class="line">	ldconfig</span><br><span class="line">	</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean main_none main_default main_library_path  main_l cmp_default_libpath cmp_l_default cmp_all</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>C++</category>
        <category>编译链接</category>
      </categories>
  </entry>
  <entry>
    <title>运行期加载时共享库路径搜索优先级实验</title>
    <url>/2024/08/01/cpp-shared-lib-search-priority-test-loading/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a class="link"   href="https://www.cnblogs.com/paw5zx/p/18302745" >《共享库链接和加载时的路径搜索优先级》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中提到，共享库在运行期加载时的路径搜索优先级为：<br><code>RPATH</code>&gt;<code>LD_LIBRARY_PATH</code>&gt;<code>RUNPATH</code>&gt;<code>/etc/ld.so.conf</code>和<code>/etc/ld.so.conf.d/*</code>&gt;<code>默认库路径</code></p>
<p>本实验分两步验证上述结论<br>①单独测试每种方法指定的路径的可行性<br>②查看链接器输出的详细信息，验证上述优先级顺序</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>操作系统：<code>Ubuntu 20.04</code><br>编译器：<code>g++-11.4.0</code><br>make：<code>GNU Make 4.2.1</code></p>
<h1 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h1><p>项目的目录结构如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── lib</span><br><span class="line">├── obj</span><br><span class="line">├── libhello.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── run_cmp_all.sh</span><br><span class="line">├── run_default.sh</span><br><span class="line">├── run_ld_library_path.sh</span><br><span class="line">├── run_ld_so_cache.sh</span><br><span class="line">├── run_none.sh</span><br><span class="line">├── run_rpath.sh</span><br><span class="line">├── run_runpath.sh</span><br><span class="line">└── makefile</span><br></pre></td></tr></table></figure></div>
<p>其中：</p>
<ul>
<li><code>lib</code>为存放共享库的文件夹</li>
<li><code>obj</code>为存放可重定位目标文件的文件夹</li>
<li><code>libhello.cpp</code>为共享库源码，它将被编译为<code>libhello.so.1.1.0</code>（soname为<code>libhello.so.1</code>）</li>
<li><code>mian.cpp</code>为主函数，其中调用了hello函数</li>
<li><code>run_cmp_all.sh</code>为对比测试上述路径优先级的脚本</li>
<li><code>run_default.sh</code>为单独测试默认路径可行性的脚本</li>
<li><code>run_ld_library_path.sh</code>为单独测试LD_LIBRARY_PATH可行性的脚本</li>
<li><code>run_ld_so_cache.sh</code>为单独测试ld.so.cache可行性的脚本</li>
<li><code>run_none.sh</code>为不配置任何路径的脚本，用于演示搜索不到动态库文件，程序无法运行的情况</li>
<li><code>run_rpath.sh</code>为单独测试RPATH可行性的脚本</li>
<li><code>run_runpath.sh</code>为单独测试RUNPATH可行性的脚本</li>
<li><code>makefile</code>为自动化构建脚本</li>
</ul>
<p>本文主要讨论运行期的加载过程，因此不对编译期的过程做过多解释，内容详见<code>makefile</code>文件</p>
<p>在附录中，我将提供本次实验涉及到的代码。</p>
<h1 id="单独测试"><a href="#单独测试" class="headerlink" title="单独测试"></a>单独测试</h1><h2 id="不配置路径"><a href="#不配置路径" class="headerlink" title="不配置路径"></a>不配置路径</h2><p>不做任何路径的配置并且不在默认路径下放置<code>libhello.so.1</code>文件，查看程序是否可以运行成功。</p>
<p>直接运行脚本即可完成上述操作：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh ./run_none.sh</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./hello: error <span class="keyword">while</span> loading shared libraries: libhello.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure></div>

<p>可以看到由于我们没有配置任何额外的搜索路径，并且没有在默认搜索路径下放置<code>libhello.so.1</code>文件，动态链接器就找不到相应的共享库文件，就会导致加载失败，程序无法运行。</p>
<h2 id="默认路径"><a href="#默认路径" class="headerlink" title="默认路径"></a>默认路径</h2><p><strong>①</strong>将<code>libhello.so.1.1.0</code>拷贝至默认搜索路径<code>/usr/lib</code>，并在<code>/usr/lib</code>下创建一个软链接（<code>libhello.so.1</code>）指向它<br><strong>②</strong>运行可执行文件。</p>
<p>直接运行脚本即可完成上述操作：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh ./run_default.sh</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Hello from the 1.1.0 library!</span><br></pre></td></tr></table></figure></div>
<p>没有报错。</p>
<h2 id="ld-so-cache"><a href="#ld-so-cache" class="headerlink" title="ld.so.cache"></a>ld.so.cache</h2><p><strong>①</strong>创建路径<code>/opt/hellolib_runtime</code><br><strong>②</strong>将<code>libhello.so.1.1.0</code>拷贝至<code>/opt/hellolib_runtime</code>，并在<code>/opt/hellolib_runtime</code>下创建一个软链接（<code>libhello.so.1</code>）指向它<br><strong>③</strong>向<code>/etc/ld.so.conf.d</code>中新增一个配置文件<code>libhello.conf</code>，并向其中写入动态库文件所在的路径<code>/opt/hellolib_runtime</code><br><strong>④</strong>使用<code>ldconfig</code>命令更新ld.so.cache<br><strong>⑤</strong>运行可执行文件</p>
<p>直接运行脚本即可完成上述操作：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh ./run_ld_so_cache.sh</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Hello from the 1.1.0 library!</span><br></pre></td></tr></table></figure></div>
<p>没有报错。</p>
<h2 id="RUNPATH"><a href="#RUNPATH" class="headerlink" title="RUNPATH"></a>RUNPATH</h2><p><strong>①</strong>在编译期添加<code>-Wl,--enable-new-dtags,-rpath,/opt/hellolib_runtime</code>指定RUNPATH<br><strong>②</strong>将<code>libhello.so.1.1.0</code>拷贝至<code>/opt/hellolib_runtime</code>，并在<code>/opt/hellolib_runtime</code>下创建一个软链接（<code>libhello.so.1</code>）指向它<br><strong>③</strong>运行可执行文件</p>
<p>直接运行脚本即可完成上述操作：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh ./run_runpath.sh</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Hello from the 1.1.0 library!</span><br></pre></td></tr></table></figure></div>
<p>没有报错。</p>
<h2 id="LD-LIBRARY-PATH"><a href="#LD-LIBRARY-PATH" class="headerlink" title="LD_LIBRARY_PATH"></a>LD_LIBRARY_PATH</h2><p><strong>①</strong>创建路径<code>/opt/hellolib_runtime</code><br><strong>②</strong>将<code>libhello.so.1.1.0</code>拷贝至<code>/opt/hellolib_runtime</code>，并在<code>/opt/hellolib_runtime</code>下创建一个软链接（<code>libhello.so.1</code>）指向它<br><strong>③</strong>向环境变量LD_LIBRARY_PATH中添加<code>/opt/hellolib_runtime</code><br><strong>④</strong>运行可执行文件</p>
<p>直接运行脚本即可完成上述操作：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh ./run_ld_library_path.sh</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Hello from the 1.1.0 library!</span><br></pre></td></tr></table></figure></div>
<p>没有报错。</p>
<h2 id="RPATH"><a href="#RPATH" class="headerlink" title="RPATH"></a>RPATH</h2><p><strong>①</strong>在编译期添加<code>-Wl,--disable-new-dtags,-rpath,/opt/hellolib_runtime</code>指定RPATH<br><strong>②</strong>将<code>libhello.so.1.1.0</code>拷贝至<code>/opt/hellolib_runtime</code>，并在<code>/opt/hellolib_runtime</code>下创建一个软链接（<code>libhello.so.1</code>）指向它<br><strong>③</strong>运行可执行文件</p>
<p>直接运行脚本即可完成上述操作：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh ./run_rpath.sh</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Hello from the 1.1.0 library!</span><br></pre></td></tr></table></figure></div>
<p>没有报错。</p>
<h1 id="优先级测试"><a href="#优先级测试" class="headerlink" title="优先级测试"></a>优先级测试</h1><p>在此模块我们要测试共享库在运行期加载时的路径搜索优先级（<strong>没有测RUNPATH，有兴趣的朋友可以自行测试一下</strong>），关键步骤如下：<br><strong>①</strong>创建路径<code>/opt/hellolib_runtime</code>,<code>/opt/hellolib_runtime1</code>,<code>/opt/hellolib_runtime2</code><br><strong>②</strong>在编译期添加<code>-Wl,--disable-new-dtags,-rpath,/opt/hellolib_runtime</code>指定RPATH<br><strong>③</strong>向环境变量LD_LIBRARY_PATH中添加<code>/opt/hellolib_runtime1</code><br><strong>④</strong>向<code>/etc/ld.so.conf.d</code>中新增一个配置文件<code>libhello.conf</code>，向其中写入路径<code>/opt/hellolib_runtime2</code>，并使用<code>ldconfig</code>命令更新ld.so.cache<br><strong>⑤</strong>将<code>libhello.so.1.1.0</code>拷贝至默认搜索路径<code>/usr/lib</code>，并在<code>/usr/lib</code>下创建一个软链接（<code>libhello.so.1</code>）指向它<br><strong>⑥</strong>运行可执行文件</p>
<p>直接运行脚本即可完成上述操作：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh ./run_cmp_all.sh</span><br></pre></td></tr></table></figure></div>

<p>在脚本中，我设置了环境变量<code>LD_DEBUG=libs</code>，启用了动态链接器的调试输出（针对库的加载过程），因此终端输出了以下信息（仅截取关键部分）：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> 	460445:     find library=libhello.so.1 [0]; searching</span><br><span class="line">    460445:      search path=/opt/hellolib_runtime/tls/haswell/x86_64:/opt/hellolib_runtime/tls/haswell:/opt/hellolib_runtime/tls/x86_64:/opt/hellolib_runtime/tls:/opt/hellolib_runtime/haswell/x86_64:/opt/hellolib_runtime/haswell:/opt/hellolib_runtime/x86_64:/opt/hellolib_runtime            (RPATH from file ./hello_rpath)</span><br><span class="line">...</span><br><span class="line">    460445:       trying file=/opt/hellolib_runtime/libhello.so.1</span><br><span class="line">    460445:      search path=/opt/hellolib_runtime1/tls/haswell/x86_64:/opt/hellolib_runtime1/tls/haswell:/opt/hellolib_runtime1/tls/x86_64:/opt/hellolib_runtime1/tls:/opt/hellolib_runtime1/haswell/x86_64:/opt/hellolib_runtime1/haswell:/opt/hellolib_runtime1/x86_64:/opt/hellolib_runtime1:tls/haswell/x86_64:tls/haswell:tls/x86_64:tls:haswell/x86_64:haswell:x86_64:               (LD_LIBRARY_PATH)</span><br><span class="line">...</span><br><span class="line">    460445:       trying file=/opt/hellolib_runtime1/libhello.so.1</span><br><span class="line">...</span><br><span class="line">    460445:      search cache=/etc/ld.so.cache</span><br><span class="line">    460445:      search path=/lib/x86_64-linux-gnu/tls/haswell/x86_64:/lib/x86_64-linux-gnu/tls/haswell:/lib/x86_64-linux-gnu/tls/x86_64:/lib/x86_64-linux-gnu/tls:/lib/x86_64-linux-gnu/haswell/x86_64:/lib/x86_64-linux-gnu/haswell:/lib/x86_64-linux-gnu/x86_64:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu/tls/haswell/x86_64:/usr/lib/x86_64-linux-gnu/tls/haswell:/usr/lib/x86_64-linux-gnu/tls/x86_64:/usr/lib/x86_64-linux-gnu/tls:/usr/lib/x86_64-linux-gnu/haswell/x86_64:/usr/lib/x86_64-linux-gnu/haswell:/usr/lib/x86_64-linux-gnu/x86_64:/usr/lib/x86_64-linux-gnu:/lib/tls/haswell/x86_64:/lib/tls/haswell:/lib/tls/x86_64:/lib/tls:/lib/haswell/x86_64:/lib/haswell:/lib/x86_64:/lib:/usr/lib/tls/haswell/x86_64:/usr/lib/tls/haswell:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/haswell/x86_64:/usr/lib/haswell:/usr/lib/x86_64:/usr/lib            (system search path)</span><br><span class="line">...</span><br><span class="line">    460445:       trying file=/lib/libhello.so.1</span><br></pre></td></tr></table></figure></div>

<p>可以看出动态链接器依次搜索了：RPATH指定的路径，LD_LIBRARY_PATH记录的路径，ld.so.cache中记录的路径，默认路径。</p>
<p>因此验证了上述的路径搜索优先级的顺序。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="库文件源码"><a href="#库文件源码" class="headerlink" title="库文件源码"></a>库文件源码</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: libhello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from the 1.1.0 library!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="主程序源码"><a href="#主程序源码" class="headerlink" title="主程序源码"></a>主程序源码</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file: makefile</span></span><br><span class="line">CXX = g++</span><br><span class="line">CXXFLAGS = -fPIC</span><br><span class="line">LDFLAGS = -shared</span><br><span class="line">DEBUG_MODE ?= 0</span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG_MODE)</span>,1)</span><br><span class="line">    DEBUG_OPTS = -v -Wl,--verbose</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"> </span><br><span class="line"><span class="section">all: lib/libhello.so.1.1.0 obj/main.o</span></span><br><span class="line"> </span><br><span class="line"><span class="section">lib/libhello.so.1.1.0: libhello.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> <span class="variable">$(LDFLAGS)</span> -Wl,-soname,libhello.so.1</span><br><span class="line"> </span><br><span class="line"><span class="section">obj/main.o: main.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 仅使用-L</span></span><br><span class="line"><span class="section">hello: obj/main.o</span></span><br><span class="line">	mkdir -p /opt/hellolib_compile</span><br><span class="line">	cp ./lib/libhello.so.1.1.0 /opt/hellolib_compile</span><br><span class="line">	ln -sf /opt/hellolib_compile/libhello.so.1.1.0 /opt/hellolib_compile/libhello.so</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(DEBUG_OPTS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -L/opt/hellolib_compile -lhello</span><br><span class="line"></span><br><span class="line"><span class="section">hello_rpath: obj/main.o</span></span><br><span class="line">	mkdir -p /opt/hellolib_compile</span><br><span class="line">	cp ./lib/libhello.so.1.1.0 /opt/hellolib_compile</span><br><span class="line">	ln -sf /opt/hellolib_compile/libhello.so.1.1.0 /opt/hellolib_compile/libhello.so</span><br><span class="line">	mkdir -p /opt/hellolib_runtime</span><br><span class="line">	cp ./lib/libhello.so.1.1.0 /opt/hellolib_runtime</span><br><span class="line">	ln -sf /opt/hellolib_runtime/libhello.so.1.1.0 /opt/hellolib_runtime/libhello.so.1</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(DEBUG_OPTS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -Wl,--disable-new-dtags,-rpath,/opt/hellolib_runtime -L/opt/hellolib_compile -lhello</span><br><span class="line"></span><br><span class="line"><span class="section">hello_runpath: obj/main.o</span></span><br><span class="line">	mkdir -p /opt/hellolib_compile</span><br><span class="line">	cp ./lib/libhello.so.1.1.0 /opt/hellolib_compile</span><br><span class="line">	ln -sf /opt/hellolib_compile/libhello.so.1.1.0 /opt/hellolib_compile/libhello.so</span><br><span class="line">	mkdir -p /opt/hellolib_runtime</span><br><span class="line">	cp ./lib/libhello.so.1.1.0 /opt/hellolib_runtime</span><br><span class="line">	ln -sf /opt/hellolib_runtime/libhello.so.1.1.0 /opt/hellolib_runtime/libhello.so.1</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(DEBUG_OPTS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -Wl,--enable-new-dtags,-rpath,/opt/hellolib_runtime -L/opt/hellolib_compile -lhello</span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f ./lib/* ./obj/* ./hello*</span><br><span class="line">	rm -f /usr/lib/libhello*</span><br><span class="line">	rm -rf /opt/hellolib_compile*</span><br><span class="line">	rm -rf /opt/hellolib_runtime*</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean hello hello_rpath hello_runpath</span></span><br></pre></td></tr></table></figure></div>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="run-none"><a href="#run-none" class="headerlink" title="run_none"></a>run_none</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make hello</span><br><span class="line"></span><br><span class="line">LD_DEBUG=libs ./hello</span><br><span class="line"></span><br><span class="line">make clean</span><br></pre></td></tr></table></figure></div>
<h3 id="run-default"><a href="#run-default" class="headerlink" title="run_default"></a>run_default</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make hello</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> ./lib/libhello.so.1.1.0 /usr/lib</span><br><span class="line"><span class="built_in">ln</span> -sf /usr/lib/libhello.so.1.1.0 /usr/lib/libhello.so.1</span><br><span class="line"></span><br><span class="line">LD_DEBUG=libs ./hello</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -f /usr/lib/libhello.so*</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure></div>
<h3 id="run-ld-so-cache"><a href="#run-ld-so-cache" class="headerlink" title="run_ld_so_cache"></a>run_ld_so_cache</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make hello</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/hellolib_runtime</span><br><span class="line"><span class="built_in">cp</span> ./lib/libhello.so.1.1.0 /opt/hellolib_runtime</span><br><span class="line"><span class="built_in">ln</span> -sf /opt/hellolib_runtime/libhello.so.1.1.0 /opt/hellolib_runtime/libhello.so.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/opt/hellolib_runtime&quot;</span> &gt; /etc/ld.so.conf.d/libhello.conf</span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line">LD_DEBUG=libs ./hello</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf /opt/hellolib_runtime*</span><br><span class="line"><span class="built_in">rm</span> -f /etc/ld.so.conf.d/libhello.conf</span><br><span class="line">ldconfig</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure></div>
<h3 id="run-runpath"><a href="#run-runpath" class="headerlink" title="run_runpath"></a>run_runpath</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make hello_runpath</span><br><span class="line"></span><br><span class="line">LD_DEBUG=libs ./hello_runpath</span><br><span class="line"></span><br><span class="line">make clean</span><br></pre></td></tr></table></figure></div>
<h3 id="run-ld-library-path"><a href="#run-ld-library-path" class="headerlink" title="run_ld_library_path"></a>run_ld_library_path</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make hello</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/hellolib_runtime</span><br><span class="line"><span class="built_in">cp</span> ./lib/libhello.so.1.1.0 /opt/hellolib_runtime</span><br><span class="line"><span class="built_in">ln</span> -sf /opt/hellolib_runtime/libhello.so.1.1.0 /opt/hellolib_runtime/libhello.so.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/opt/hellolib_runtime:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br><span class="line">LD_DEBUG=libs ./hello</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf /opt/hellolib_runtime*</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure></div>
<h3 id="run-rpath"><a href="#run-rpath" class="headerlink" title="run_rpath"></a>run_rpath</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make hello_rpath</span><br><span class="line"></span><br><span class="line">LD_DEBUG=libs ./hello_rpath</span><br><span class="line"></span><br><span class="line">make clean</span><br></pre></td></tr></table></figure></div>
<h3 id="run-cmp-all"><a href="#run-cmp-all" class="headerlink" title="run_cmp_all"></a>run_cmp_all</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make hello_rpath</span><br><span class="line"><span class="built_in">rm</span> -rf /opt/hellolib_runtime/*</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/hellolib_runtime1</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/opt/hellolib_runtime1:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/hellolib_runtime2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/opt/hellolib_runtime2&quot;</span> &gt; /etc/ld.so.conf.d/libhello.conf</span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> ./lib/libhello.so.1.1.0 /usr/lib</span><br><span class="line"><span class="built_in">ln</span> -sf /usr/lib/libhello.so.1.1.0 /usr/lib/libhello.so.1</span><br><span class="line"></span><br><span class="line">LD_DEBUG=libs ./hello_rpath</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -f /usr/lib/libhello.so*</span><br><span class="line"><span class="built_in">rm</span> -f /etc/ld.so.conf.d/libhello.conf</span><br><span class="line">ldconfig</span><br><span class="line"><span class="built_in">rm</span> -rf /opt/hellolib_runtime*</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>C++</category>
        <category>编译链接</category>
      </categories>
  </entry>
  <entry>
    <title>共享库链接和加载时的路径搜索优先级</title>
    <url>/2024/07/15/cpp-shared-lib-search-priority/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开发一个新项目时遇到了共享库冲突的问题，因此在这里记录一下共享库的链接和加载过程中库路径的搜索优先级的相关知识。</p>
<h1 id="共享库的链接"><a href="#共享库的链接" class="headerlink" title="共享库的链接"></a>共享库的链接</h1><p>现在有一个<code>main.o</code>可重定位目标文件，其中需要用到开源库log4cpp。在链接的时候，我们可以这样链接：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">g++ main.o -o a.out -L/path/to/libs -llog4cpp</span><br></pre></td></tr></table></figure></div>
<p>其中：<br><code>-L/path/to/libs</code>表示链接器去哪个目录下查找库文件。<br>注意：通过-L指定的路径的搜索优先级是要高于系统默认的库文件路径的。</p>
<p>使用g++编译时库搜索优先级：<br><code>-L指定的路径</code>&gt;<code>默认库路径</code>&gt;<code>LIBRARY_PATH指定路径</code><br>(我看网上都说优先级为：<code>-L指定的路径</code>&gt;<code>LIBRARY_PATH指定路径</code>&gt;<code>默认库路径</code>，但是我做了个实验发现使用g++时不是这样的，实验过程见<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18330701" >《编译期链接时共享库搜索路径优先级实验》
 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</p>
<p><code>-llog4cpp</code>表示要链接的库，在链接阶段，链接器一般会按照搜索优先级，从库路径中查找名为<code>liblog4cpp.so</code>或<code>liblog4cpp.a</code>的文件进行链接。若不特殊说明，默认优先链接共享库。</p>
<h1 id="共享库的加载"><a href="#共享库的加载" class="headerlink" title="共享库的加载"></a>共享库的加载</h1><p>在程序开始运行前的加载阶段，动态链接器会读取可执行文件，查找并加载所有必须的共享库。注意此时的搜索路径并不包含上述的<code>/path/to/libs</code>，因为它只作用于编译时的链接阶段。动态链接器搜索的路径有：LD_LIBRARY_PATH环境变量，<code>/etc/ld.so.cache</code>文件，默认库路径（<code>/usr/lib</code>,<code>/lib</code>等），RPATH（需编译时设置），RUNPATH（需编译时设置）。</p>
<p>如果需要从指定的路径加载共享库，则可以使用下述方法：</p>
<ul>
<li>手动设置LD_LIBRARY_PATH环境变量：在程序运行前设置环境变量，指定共享库的搜索路径：  <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/path/to/runtime_libs:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure></div>
  注意，此方法设置环境变量是临时的，一旦终端关闭设置就会失效。若想使其持久化，需要特殊设置，方法包括但不限于：修改.bashrc文件，修改rc.loacl文件。</li>
<li>修改<code>/etc/ld.so.conf</code>和<code>/etc/ld.so.conf.d/*</code>配置：<br>  这些文件提供了系统级别的库搜索路径。系统管理员可以在这些文件中定义默认的库搜索路径，这些设置对所有用户和应用程序都有效。</li>
<li>在编译期的链接阶段使用<code>-rpath</code>:<br>  在编译期的链接阶段，设置RPATH或RUNPATH，将库路径硬编码到可执行文件中  <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">g++ main.o -o a.out -L/path/to/libs -llog4cpp -Wl,-rpath,/path/to/runtime_libs</span><br></pre></td></tr></table></figure></div>
  注意若可执行文件中同时包含RPATH和RUNPATH，那么RPATH将会被动态链接器忽略。</li>
</ul>
<p>共享库的搜索优先级为：<br>    <code>RPATH</code>&gt;<code>LD_LIBRARY_PATH</code>&gt;<code>RUNPATH</code>&gt;<code>/etc/ld.so.conf</code>和<code>/etc/ld.so.conf.d/*</code>&gt;<code>默认库路径</code><br>我做了个实验验证上述优先级，详见：<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18337485" >《运行期加载时共享库路径搜索优先级实验》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>编译链接</category>
      </categories>
  </entry>
  <entry>
    <title>共享库soname机制</title>
    <url>/2024/07/16/cpp-shared-lib-soname/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用第三方库时，我们会发现第三方库会提供一组文件，他们的后缀一般是<code>.so</code>（如<code>libname.so</code>），<code>.so.x</code>和<code>.so.x.y.z</code>。本文讨论他们之间的关系。</p>
<h1 id="共享库版本号"><a href="#共享库版本号" class="headerlink" title="共享库版本号"></a>共享库版本号</h1><p>共享库一般会由于修复bug或增加接口等原因不断更新，有些更新是向下兼容的，有些则不是。一旦不向下兼容，那么当共享库更新后，依赖该库的程序将无法运行，需要重新编译。</p>
<p>为了避免上述情况，就要对共享库进行版本控制。根据更新内容的不同可以划分不同的版本号：</p>
<ul>
<li><strong>主版本号（Major Version Number）</strong>：主版本号表示库的重大升级，即更新的内容会导致不再与旧版本兼容（如接口变更），需要用户做出代码上的修改来适应新版本（或者仍使用旧版的共享库）。</li>
<li><strong>次版本号（Minor Version Number）</strong>：次版本号表示库的增量升级，即更新的内容向下兼容，不会影响用户程序，但提供了额外的功能或改进。用户不需要做出代码更改仍可继续使用该库。</li>
<li><strong>发布版本号（Release Version Number）</strong>：发布版本号表示库的一些错误的修正、性能的改进等，接口不做变化，不添加新功能。向下兼容。</li>
</ul>
<p>不同的版本号在文件命名上就可以体现。<br>对于一个名为<code>aaa</code>的库，它的共享库文件名可能为：<code>libaaa.so.x.y.z</code>，其中：</p>
<ul>
<li><code>lib</code>：固定前缀</li>
<li><code>aaa</code>：库名称</li>
<li><code>.so</code>：共享库固定后缀</li>
<li><code>.x</code>：主版本号</li>
<li><code>.y</code>：次版本号</li>
<li><code>.z</code>：发布版本号</li>
</ul>
<p>例如<code>libjsoncpp.so.1.7.4</code>就代表着<code>jsoncpp</code>的共享库文件，版本号为1.7.4</p>
<h1 id="共享库命名机制"><a href="#共享库命名机制" class="headerlink" title="共享库命名机制"></a>共享库命名机制</h1><p>然而若一个共享库改变了版本号并更新文件。那么对于使用旧版本共享库的用户程序来说，运行时就无法找到共享库文件了（因为名称已改变），还需要重新编译链接才可以。这就这大大增加了系统维护的复杂度和成本。</p>
<p>于是就诞生了SONAME命名机制，方便管理共享库的版本。</p>
<p>此机制设计了3类命名方式：</p>
<h2 id="realname"><a href="#realname" class="headerlink" title="realname"></a>realname</h2><ul>
<li>形如<code>libname.so.x.y.z</code>，<code>x,y,z</code>分别代表主版本号，次版本号和发布版本号。</li>
<li>一般拥有此名称的文件就是共享库的源文件</li>
<li>在库文件生成时使用下面命令可以指定realname：  <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -o $(realname) $(dependencies) $(flags)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="soname"><a href="#soname" class="headerlink" title="soname"></a>soname</h2><ul>
<li>形如<code>libname.so.x</code>，<code>x</code>代表主版本号</li>
<li>作用于用户程序运行时的加载阶段，动态链接器会根据用户程序编译时记录的soname查找对应的共享库文件</li>
<li>通常是<code>$(realname)</code>文件的软链接，在库安装或更新后由库的维护者或系统管理员通过包管理器更新软链接的指向，一般不由单个用户手动进行软链接。</li>
<li>在库文件生成时使用下面命令可以指定其soname：  <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -o $(realname) $(dependencies) $(flags) −Wl,−soname,$(soname)</span><br></pre></td></tr></table></figure></div></li>
<li>对于一个共享库文件，我们可以通过<code>readelf -d</code>命令查看其soname<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/16/cpp-shared-lib-soname/readelf.png"
                     
                ></li>
</ul>
<h2 id="linkname"><a href="#linkname" class="headerlink" title="linkname"></a>linkname</h2><ul>
<li>形如<code>libname.so</code>，是没有任何版本编号的文件名</li>
<li>作用于用户程序编译阶段，链接器使用linkname来寻找对应的共享库（GCC中使用-l选项指定库，如<code>-laaa</code>，链接器就会去找<code>libaaa.so</code>），然后将共享库的soname记录在用户程序的动态链接信息中。</li>
<li>通常是<code>$(realname)</code>文件或<code>$(soname)</code>文件的软链接，在库安装或更新后由库的维护者或系统管理员通过包管理器更新软链接的指向，一般不由单个用户手动进行软链接。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，对于Linux下的用户程序，soname命名机制主要参与了以下两个过程：</p>
<p>①<strong>链接阶段</strong>：链接器按照搜索路径优先级，根据linkname去找对应的<code>.so</code>文件，如果找到了就会在生成的可执行文件中记录<code>.so</code>文件指向的共享库文件的soname；如果没有找到就会去找静态库文件选择静态链接。</p>
<p>②<strong>加载阶段</strong>：程序运行时，动态链接器按照搜索路径优先级，根据可执行文件中记录的soname去找对应的<code>*.so.x</code>文件，如果找到了就会加载其指向的共享库；没找到就报错。</p>
<p>这样的处理确保了应用程序在运行时能够找到合适的库版本，同时允许系统管理员在不影响已有应用程序的情况下更新库文件。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a class="link"   href="https://blog.csdn.net/J_H_C/article/details/98375371" >Linux下动态链接库文件的realname、soname和linkname <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>2.<a class="link"   href="https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html" >Program Library HOWTO-Shared Libraries <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>3.<a class="link"   href="https://octo.org.uk/posts/shared-object-names/" >Shared objects: sonames, real names, and link names <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>4.<a class="link"   href="https://linuxstory.org/soname-of-linux-shared-library/" >Linux 共享库的 soname 命名机制 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>编译链接</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式学习（二）工厂模式——抽象工厂模式+注册表</title>
    <url>/2024/07/09/design-pattern-2-abstract-factory-reflect/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18286354" >上一篇文章中 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>我们提到了抽象工厂模式初版代码的一些缺点：①客户端违反开闭原则②提供方违反开闭原则。本文将针对这两点进行讨论</p>
<h1 id="使用简单工厂改进"><a href="#使用简单工厂改进" class="headerlink" title="使用简单工厂改进"></a>使用简单工厂改进</h1><p>对于缺点①，我们可以使用简单工厂的思路来改进抽象工厂的初版代码。对于上一篇文章中的例子，我们去除<code>CameraFactory</code>、<code>BaslerCameraFactory</code>和<code>SickCameraFactory</code>，取而代之的是<code>SimpleFactory</code>类。</p>
<p>类图如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/09/design-pattern-2-abstract-factory-reflect/uml.png"
                     
                ></p>
<p>代码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">BaslerCamera* <span class="title">CreateBaslerCamera</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Linux&quot;</span> == os_name_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LinuxBaslerCamera</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Windows&quot;</span> == os_name_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsBaslerCamera</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SickCamera* <span class="title">CreateSickCamera</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Linux&quot;</span> == os_name_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LinuxSickCamera</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Windows&quot;</span> == os_name_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsSickCamera</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string os_name_ = <span class="string">&quot;Linux&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SimpleFactory* camera_factory = <span class="keyword">new</span> <span class="built_in">SimpleFactory</span>();</span><br><span class="line">   </span><br><span class="line">    BaslerCamera* basler_camera = camera_factory-&gt;<span class="built_in">CreateBaslerCamera</span>();</span><br><span class="line">    basler_camera-&gt;<span class="built_in">OpenCamera</span>();</span><br><span class="line"></span><br><span class="line">    SickCamera* sick_camera = camera_factory-&gt;<span class="built_in">CreateSickCamera</span>();</span><br><span class="line">    sick_camera-&gt;<span class="built_in">OpenCamera</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意，上述方法虽然改进了缺点①，但是缺点②仍存在。</p>
<h1 id="使用注册表改进"><a href="#使用注册表改进" class="headerlink" title="使用注册表改进"></a>使用注册表改进</h1><p>对于缺点②，其本质是：增加新产品时，对工厂类带来的修改违反了开闭原则。对于这种情况，我们可以参考<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18229334" >《设计模式学习（二）工厂模式——工厂方法模式+注册表》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中提到的注册表，来去除<code>switch</code>或<code>if</code>这种分支判断，解除分支判断带来的耦合。</p>
<p>对于具体产品，我们可以这样将它注册：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxBaslerCamera</span> : <span class="keyword">public</span> BaslerCamera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">LinuxBaslerCamera</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ReflectRegister</span>(<span class="string">&quot;LinuxBasler&quot;</span>, LinuxBaslerCamera);</span><br></pre></td></tr></table></figure></div>
<p>然后工厂类的代码可以简化为：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">BaslerCamera* <span class="title">CreateBaslerCamera</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string name = os_name_ + <span class="string">&quot;Basler&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Object::<span class="built_in">CreateObject</span>&lt;BaslerCamera&gt;(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SickCamera* <span class="title">CreateSickCamera</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string name = os_name_ + <span class="string">&quot;Sick&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Object::<span class="built_in">CreateObject</span>&lt;SickCamera&gt;(name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string os_name_ = <span class="string">&quot;Linux&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这样，在产品族增加时（比如增加一个<code>HarmonyOS</code>），我们只需要在它下面的产品类对应的文件中使用<code>ReflectRegister</code>注册，然后改变<code>os_name_</code>即可（当然<code>os_name_</code>也可以在运行时从配置文件中加载，这样更好）。</p>
<p>而对于现有的产品族内增加新产品（比如增加一个<code>Huaray</code>相机），工厂类中还是要增加一个<code>CreateHuarayCamera</code>函数。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.《大话设计模式》</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++设计模式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习（二）工厂模式——抽象工厂模式</title>
    <url>/2024/07/05/design-pattern-2-abstract-factory/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现在我需要开发一个相机操作模块，它可能在<code>Windows</code>下运行，也可能在<code>Linux</code>下运行。由于在厂家提供的SDK中，<code>Windows</code>下的SDK和<code>Linux</code>下的SDK是有区别的，因此对于一个品牌的相机，我们要创建两个类去封装这两个不同平台下的API。</p>
<p>我们先使用工厂方法模式去设计（以<code>Basler</code>相机为例），类图如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/05/design-pattern-2-abstract-factory/uml_factory.png"
                     
                ></p>
<p>对应的代码（就不用智能指针了，要不然类图不好画）：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaslerCamera</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BaslerCamera</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">OpenCamera</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxBaslerCamera</span> : <span class="keyword">public</span> BaslerCamera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">LinuxBaslerCamera</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsBaslerCamera</span> : <span class="keyword">public</span> BaslerCamera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">WindowsBaslerCamera</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CameraFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CameraFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BaslerCamera* <span class="title">CreateBaslerCamera</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxCameraFactory</span> : <span class="keyword">public</span> CameraFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">BaslerCamera* <span class="title">CreateBaslerCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LinuxBaslerCamera</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsCameraFactory</span> : <span class="keyword">public</span> CameraFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">BaslerCamera* <span class="title">CreateBaslerCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsBaslerCamera</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果更换平台，客户端代码只需要修改这一处</span></span><br><span class="line">    CameraFactory* cameraFactory = <span class="keyword">new</span> <span class="built_in">LinuxCameraFactory</span>();</span><br><span class="line">    </span><br><span class="line">    BaslerCamera* camera = cameraFactory-&gt;<span class="built_in">CreateBaslerCamera</span>();</span><br><span class="line">    </span><br><span class="line">    camera-&gt;<span class="built_in">OpenCamera</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>现在若新增了一个品牌的相机：<code>Sick</code>，那么按照工厂方法模式的设计思路，就会为其创建出对应的抽象工厂类和具体工厂类（具体代码略）。</p>
<p>但是进一步分析可以发现，对于这个模块，它要么在<code>Windows</code>下运行，要么在<code>Linux</code>下运行。即对于抽象产品<code>BaslerCamera</code>和<code>SickCamera</code>，要么实例化<code>LinuxBaslerCamera</code>和<code>LinuxSickCamera</code>，要么实例化<code>WindowsBaslerCamera</code>和<code>WindowsSickCamera</code> 。</p>
<p>可以说不同的相机被划分在Linux相机和Window相机这两个产品族下，因此我们不需要为每一个品牌的相机都去实现一组对应的工厂类，而是只使用两个工厂<code>WindowsCameraFactory</code>和<code>LinuxCameraFactory</code>去管理各自对应平台下的相机的创建过程。</p>
<p>那么工厂类的代码就会变成这样：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CameraFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CameraFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BaslerCamera* <span class="title">CreateBaslerCamera</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SickCamera* <span class="title">CreateSickCamera</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxCameraFactory</span> : <span class="keyword">public</span> CameraFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">BaslerCamera* <span class="title">CreateBaslerCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LinuxBaslerCamera</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SickCamera* <span class="title">CreateSickCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LinuxSickCamera</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsCameraFactory</span> : <span class="keyword">public</span> CameraFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">BaslerCamera* <span class="title">CreateBaslerCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsBaslerCamera</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SickCamera* <span class="title">CreateSickCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsSickCamera</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这就引出了抽象工厂模式</p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><blockquote>
<p>抽象工厂模式，提供一个创建<strong>一系列</strong>相关或相互依赖对象的接口，而无需指定他们具体的类</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/05/design-pattern-2-abstract-factory/uml.png"
                     
                ></p>
<p><code>AbstractProductA</code>和<code>AbstractProductB</code>是两个抽象产品，之所以为抽象，是因为他们可能有多种不同的实现，就刚才的例子来说，抽象产品就是<code>BaslerCamera</code>和<code>SickCamera</code>。<code>ProductA1</code>，<code>ProductA2</code>，<code>ProductB1</code>，<code>ProductB2</code>就是对两个抽象产品的具体分类的实现，对应例子中的<code>LinuxBaslerCamera</code>，<code>WindowsBaslerCamera</code>，<code>LinuxSickCamera</code>，<code>WindowsSickCamera</code>。</p>
<p><code>AbstractFactory</code>是一个抽象工厂基类，对应例子中的<code>CameraFactory</code>，它里面应该包含产品族中每个产品创建的抽象方法。<code>ConcreteFactory1</code>和<code>ConcreteFactory2</code>是具体工厂，对应例子中的<code>LinuxCameraFactory</code>和<code>WindowsCameraFactory</code>。</p>
<p>对于客户端，通常是在代码中创建一个具体工厂的实例（这个实例就对应着一个产品族），使用这个工厂实例再创建产品族内具体的产品对象。</p>
<p>客户端代码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    若在windows平台，只需将本句改为:</span></span><br><span class="line"><span class="comment">    CameraFactory* cameraFactory = new WindowsCameraFactory();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    CameraFactory* camera_factory = <span class="keyword">new</span> <span class="built_in">LinuxCameraFactory</span>();</span><br><span class="line">    </span><br><span class="line">    BaslerCamera* basler_camera = camera_factory-&gt;<span class="built_in">CreateBaslerCamera</span>();</span><br><span class="line">    basler_camera-&gt;<span class="built_in">OpenCamera</span>();</span><br><span class="line"></span><br><span class="line">    SickCamera* sick_camera = camera_factory-&gt;<span class="built_in">CreateSickCamera</span>();</span><br><span class="line">    sick_camera-&gt;<span class="built_in">OpenCamera</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>完整代码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaslerCamera</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BaslerCamera</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">OpenCamera</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxBaslerCamera</span> : <span class="keyword">public</span> BaslerCamera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">LinuxBaslerCamera</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsBaslerCamera</span> : <span class="keyword">public</span> BaslerCamera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">WindowsBaslerCamera</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SickCamera</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SickCamera</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">OpenCamera</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxSickCamera</span> : <span class="keyword">public</span> SickCamera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">LinuxSickCamera</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsSickCamera</span> : <span class="keyword">public</span> SickCamera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">WindowsSickCamera</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CameraFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CameraFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BaslerCamera* <span class="title">CreateBaslerCamera</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SickCamera* <span class="title">CreateSickCamera</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinuxCameraFactory</span> : <span class="keyword">public</span> CameraFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">BaslerCamera* <span class="title">CreateBaslerCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LinuxBaslerCamera</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SickCamera* <span class="title">CreateSickCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LinuxSickCamera</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsCameraFactory</span> : <span class="keyword">public</span> CameraFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">BaslerCamera* <span class="title">CreateBaslerCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsBaslerCamera</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SickCamera* <span class="title">CreateSickCamera</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsSickCamera</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若在windows平台，只需将本句改为CameraFactory* cameraFactory = new WindowsCameraFactory();</span></span><br><span class="line">    CameraFactory* camera_factory = <span class="keyword">new</span> <span class="built_in">LinuxCameraFactory</span>();</span><br><span class="line">    </span><br><span class="line">    BaslerCamera* basler_camera = camera_factory-&gt;<span class="built_in">CreateBaslerCamera</span>();</span><br><span class="line">    basler_camera-&gt;<span class="built_in">OpenCamera</span>();</span><br><span class="line"></span><br><span class="line">    SickCamera* sick_camera = camera_factory-&gt;<span class="built_in">CreateSickCamera</span>();</span><br><span class="line">    sick_camera-&gt;<span class="built_in">OpenCamera</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h1><p>优点：</p>
<ul>
<li><strong>易于更改产品族</strong>：工厂的实例化过程在一个客户端只需要出现一次，修改方便</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>提供方违反开闭原则</strong>：如果现在在每个产品族内新增一个品牌相机（如Huaray），那么除了要增加<code>HuarayCamera</code>，<code>WindowsHuarayCamera</code>，<code>LinuxHuarayCamera</code>三个产品类之外（这是必要的），还要修改<code>CameraFactory</code>，<code>LinuxCameraFactory</code>和<code>WindowsCameraFactory</code>这三个工厂类，违反了开闭原则。</li>
<li><strong>客户端违法开闭原则</strong>：客户端在开始的时候都要<code>CameraFactory* camera_factory = new LinuxCameraFactory();</code>，若是要更换为Windows平台，则还需手动修改实例化的类型，违反了开闭原则。而且如果客户端不止一个，则每一个客户端都需要手动修改，效率低。</li>
</ul>
<p>对于抽象工厂模式的改进方法，将在下一篇文章中讨论。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.《大话设计模式》</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++设计模式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习（二）工厂模式——工厂方法模式+注册表</title>
    <url>/2024/06/03/design-pattern-2-factory-method-reflect/</url>
    <content><![CDATA[<h1 id="工厂方法模式的瑕疵"><a href="#工厂方法模式的瑕疵" class="headerlink" title="工厂方法模式的瑕疵"></a>工厂方法模式的瑕疵</h1><p>在<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18197513" >前一篇笔记 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中我们介绍了工厂方法模式，示例的类图如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/03/design-pattern-2-factory-method-reflect/uml.png"
                     
                ></p>
<p>前文中提到</p>
<blockquote>
<p>工厂方法模式把提供方原来的简单工厂类的内部判断逻辑转移到了客户端代码，这让客户端代码违反了开闭原则</p>
</blockquote>
<p>下面举例说明。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>考虑一种情况：现在要在程序运行时，根据外部资源，动态的实例化对象。也就是说在编译期我们无法知道要实例化的对象的类型。因此在实例化的过程中，就需要加以判断。</p>
<p>例如，在我的例子中，要根据连接到主机的相机来实例化相机对象，那么客户端（使用工厂方法创建实例的一方）使用工厂方法模式创建对象的时候，代码可能是这样：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行时确定数组大小，且确定后不可改变</span></span><br><span class="line"><span class="keyword">auto</span> camera_devices_ = std::make_unique&lt;std::shared_ptr&lt;CameraDevice&gt;[]&gt;(onlined_camera_num_);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; onlined_camera_num_; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	std::shared_ptr&lt;CameraDeviceFactory&gt; factory;</span><br><span class="line">	<span class="keyword">if</span>(<span class="string">&quot;Sick&quot;</span> == camera_name[i])    <span class="comment">//camera_name[i]中元素是提前获取的与连接的相机对应的供应商名称</span></span><br><span class="line">		factory = std::<span class="built_in">make_shared</span>&lt;SickCameraFactory&gt;();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;Basler&quot;</span> == camera_name[i])</span><br><span class="line">		factory = std::<span class="built_in">make_shared</span>&lt;BaslerCameraFactory&gt;();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;Huaray&quot;</span> == camera_name[i])</span><br><span class="line">		factory = std::<span class="built_in">make_shared</span>&lt;HuarayCameraFactory&gt;();</span><br><span class="line">    camera_devices_[i] = factory-&gt;<span class="built_in">CreateCamera</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>虽然作为提供方，使用工厂方法模式遵循了开闭原则，即当有新类型的时候，无需修改现有的代码，只需新加产品类和对应工厂类即可。但是对于客户端来说，当需要实例化的类型数量增加时，就需要新增else if去适配，这违反了开闭原则，将使客户端代码变得冗长且难以维护。</p>
<h1 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h1><p>为了解决上面问题，我们可以实现一个类型的注册表，允许动态创建对象。这种方法通过将关键字映射到构造函数指针，使得可以根据字符串名称动态地实例化对象。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Reflection_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Reflection_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ArgType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">CreateInstance</span><span class="params">(ArgType... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要反射的类使用此宏注册，将关键词与构造函数关联</span></span><br><span class="line"><span class="comment">//此注册过程会在main函数执行之前完成</span></span><br><span class="line"><span class="comment">//因为宏定义了一个静态变量，会在main函数执行之前的静态初始化阶段被初始化</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ReflectRegister</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ReflectRegister(identifier, class_name, ...) \</span></span><br><span class="line"><span class="meta">    static bool __type##class_name = Object::Register(identifier, (void*)CreateInstance<span class="string">&lt;class_name, ##__VA_ARGS__&gt;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseClass, <span class="keyword">typename</span>... ArgType&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> BaseClass *<span class="title">CreateObject</span><span class="params">(<span class="type">const</span> std::string &amp;vendor_name, ArgType... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> CreateFactory = BaseClass *(*)(ArgType...);</span><br><span class="line">        <span class="keyword">auto</span>&amp; class_map = <span class="built_in">GetStaticFuncMap</span>();</span><br><span class="line">        <span class="keyword">auto</span> iter = class_map.<span class="built_in">find</span>(vendor_name);</span><br><span class="line">        <span class="keyword">if</span> (iter == class_map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;CreateFactory&gt;(class_map[vendor_name])(args...);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//向map中注册关键字和类的构造函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Register</span><span class="params">(<span class="type">const</span> std::string &amp;vendor_name, <span class="type">void</span> *ctor_ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">GetStaticFuncMap</span>()[vendor_name] = ctor_ptr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//获取全局唯一的map</span></span><br><span class="line">    <span class="comment">//map记录了关键字和类的构造函数的映射关系</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::map&lt;std::string, <span class="type">void</span>*&gt;&amp; <span class="title">GetStaticFuncMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::map&lt;std::string, <span class="type">void</span>*&gt; class_map_;</span><br><span class="line">        <span class="keyword">return</span> class_map_;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//Reflection_H</span></span></span><br></pre></td></tr></table></figure></div>
<p>在具体相机工厂中，我们可以使用<code>ReflectRegister</code>注册此类（以Basler相机为例，其余类似）：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaslerCameraDeviceFactory</span> : <span class="keyword">public</span> CameraDeviceFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;CameraDevice&gt; <span class="title">CreateCameraDevice</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;BaslerCameraDevice&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ReflectRegister</span>(<span class="string">&quot;Basler&quot;</span>, BaslerCameraDeviceFactory);</span><br></pre></td></tr></table></figure></div>
<p>好了，现在回头再看客户端使用工厂方法模式创建对象的代码，就可以简化为：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行时确定数组大小，且确定后不可改变</span></span><br><span class="line"><span class="keyword">auto</span> camera_devices_ = std::make_unique&lt;std::shared_ptr&lt;CameraDevice&gt;[]&gt;(onlined_camera_num_);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; onlined_camera_num_; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> p_factory = Object::<span class="built_in">CreateObject</span>&lt;CameraDeviceFactory&gt;(camera_name[i]);<span class="comment">//camera_name[i]中元素是提前获取的与连接的相机对应的供应商名称</span></span><br><span class="line">	<span class="keyword">if</span> (!p_factory)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        camera_devices_[i] = p_factory-&gt;<span class="built_in">CreateCameraDevice</span>();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">delete</span> p_factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>C++</category>
        <category>C++设计模式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习（二）工厂模式——工厂方法模式</title>
    <url>/2024/05/17/design-pattern-2-factory-method/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a class="link"   href="https://www.cnblogs.com/paw5zx/p/18191839" >前一篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>介绍了简单工厂模式，提到了简单工厂模式的缺点（违反开闭原则，扩展困难），本文要介绍的工厂方法模式在一定程度上弥补了简单工厂模式的缺点。</p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>工厂方法模式是创建型设计模式之一，它在抽象工厂类中声明创建对象的接口，在具体工厂类中实现具体的实例化过程。这个模式的核心思想是将对象的实例化延迟到子类中进行。</p>
<p>这样的话，当要添加一个具体产品时，我们不会修改原有的工厂类（对修改封闭），而是新创建一个关联于具体产品的具体工厂类（对扩展开放）。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>抽象相机类：CameraDevice<br>具体相机类：BaslerCameraDevice，SickCameraDevice，HuarayCameraDevice</p>
<p>抽象工厂类：CameraDeviceFactory<br>具体工厂类：BaslerCameraFactory，SickCameraFactory，HuarayCameraFactory</p>
<p>UML类图如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/17/design-pattern-2-factory-method/uml.png"
                     
                ></p>
<p>代码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CameraDevice</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CameraDevice</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CameraDevice</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">OpenDevice</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaslerCameraDevice</span> : <span class="keyword">public</span> CameraDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">BaslerCameraDevice</span>() <span class="keyword">override</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenDevice</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuarayCameraDevice</span> : <span class="keyword">public</span> CameraDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">HuarayCameraDevice</span>() <span class="keyword">override</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenDevice</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SickCameraDevice</span> : <span class="keyword">public</span> CameraDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SickCameraDevice</span>() <span class="keyword">override</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenDevice</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CameraDeviceFactory</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;CameraDevice&gt; <span class="title">CreateCamera</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaslerCameraFactory</span> : <span class="keyword">public</span> CameraDeviceFactory </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;CameraDevice&gt; <span class="title">CreateCamera</span><span class="params">()</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;BaslerCameraDevice&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuarayCameraFactory</span> : <span class="keyword">public</span> CameraDeviceFactory </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;CameraDevice&gt; <span class="title">CreateCamera</span><span class="params">()</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;HuarayCameraDevice&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SickCameraFactory</span> : <span class="keyword">public</span> CameraDeviceFactory </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;CameraDevice&gt; <span class="title">CreateCamera</span><span class="params">()</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;SickCameraDevice&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里还是要做条件判断，根据传入的参数确定要实例化的具体类型，过程略</span></span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;CameraDeviceFactory&gt; factory = std::<span class="built_in">make_shared</span>&lt;BaslerCameraFactory&gt;();</span><br><span class="line">    std::shared_ptr&lt;CameraDevice&gt; camera = factory-&gt;<span class="built_in">CreateCamera</span>();</span><br><span class="line">    camera-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    camera-&gt;<span class="built_in">OpenDevice</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><strong>解耦</strong>：工厂方法模式可以减少客户代码与具体类之间的耦合。客户端在使用的时候只需知道接口，而不是具体类。这样可以更容易地扩展或修改创建逻辑，而无需修改现有客户代码。</li>
<li><strong>符合开闭原则</strong>：工厂方法模式允许提供方在不修改现有代码的情况下引入新的类型。满足对扩展开放，对修改封闭的原则。</li>
<li><strong>单一职责原则</strong>：工厂方法模式中，创建对象的逻辑被封装在一个工厂类中，这符合单一职责原则。这让代码更加清晰，维护也更简单。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li><strong>代码复杂</strong>：工厂方法模式为每种产品类型提供一个单独的工厂类。这意味着每增加一个新的产品类别，就需要增加一个新的具体工厂类。这会导致类的数量迅速增加，从而增加了代码的复杂性</li>
<li><strong>代码冗余</strong>：如果具体工厂类之间的创建逻辑相似，这可能会导致代码冗余。虽然每个工厂类只负责创建一个具体产品，但这些工厂类的创建逻辑可能高度相似，不能有效地重用代码。</li>
<li><strong>客户端违反开闭原则</strong>：虽然工厂方法模式使提供方代码遵守了开闭原则，但是在客户端，仍需根据传入的参数决定具体实例化哪一个类，选择判断的问题仍存在。即工厂方法模式把提供方简单工厂类的内部判断逻辑转移到了客户端代码，这让客户端代码违反了开闭原则。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li><strong>产品类别经常变化</strong>：一个系统会频繁添加或修改产品的创建，而每种产品的创建又有不同的复杂配置和依赖时，工厂方法可以将具体产品的创建逻辑封装在各自的工厂类中，从而简化客户端代码。</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.《大话设计模式》</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++设计模式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习（二）工厂模式——简单工厂模式</title>
    <url>/2024/05/14/design-pattern-2-simple-factory/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工厂模式是一种常用的设计模式，属于创建型模式之一。它的主要目的是为了解耦组件之间的依赖关系。通过使用工厂模式，系统中的具体类的实例化过程可以被抽象出来，从而使得系统更加模块化，增强了系统的可维护性和可扩展性。</p>
<p>工厂模式可以分为三种类型：简单工厂模式，工厂方法模式和抽象工厂模式。本文先讨论简单工厂模式。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在工业相机领域，多个品牌如Basler、Sick、Huaray等，各自提供了控制相机的API。本文中我们按照提供方和使用方两个角色来进行分析，以便更好地理解工厂模式的优点：</p>
<ul>
<li>提供方：负责封装不同品牌相机的API，创建统一的接口。目的是简化相机控制的复杂性，使得使用方可以更容易地集成和操作这些相机。</li>
<li>使用方（客户端）：利用提供方开发的代码，根据自己的具体需求，实例化选定的相机品牌，并执行所需的操作</li>
</ul>
<h1 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h1><p>在一般方法中：<br>①提供方封装了三个不同品牌的相机类，其中包含了他们各自的相机操作函数<br>②使用方（即main函数），根据外部传入的相机品牌名称，来实例化具体相机对象，然后对其进行一系列操作。</p>
<p>代码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaslerCameraDevice</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">BaslerCameraDevice</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenDevice</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuarayCameraDevice</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">HuarayCameraDevice</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenDevice</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SickCameraDevice</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SickCameraDevice</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenDevice</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string vendor_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;Basler&quot;</span> == vendor_name)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;BaslerCameraDevice&gt; camera = std::<span class="built_in">make_shared</span>&lt;BaslerCameraDevice&gt;();</span><br><span class="line">        camera-&gt;<span class="built_in">Init</span>();</span><br><span class="line">        camera-&gt;<span class="built_in">OpenDevice</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;Huaray&quot;</span> == vendor_name)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;HuarayCameraDevice&gt; camera = std::<span class="built_in">make_shared</span>&lt;HuarayCameraDevice&gt;();</span><br><span class="line">        camera-&gt;<span class="built_in">Init</span>();</span><br><span class="line">        camera-&gt;<span class="built_in">OpenDevice</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;Sick&quot;</span> == vendor_name)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;SickCameraDevice&gt; camera = std::<span class="built_in">make_shared</span>&lt;SickCameraDevice&gt;();</span><br><span class="line">        camera-&gt;<span class="built_in">Init</span>();</span><br><span class="line">        camera-&gt;<span class="built_in">OpenDevice</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码虽然比较直观，容易理解，但不利于维护和扩展。</p>
<p>比如现在需要新增一个品牌的相机，那么除了在提供方中增加一个对新品牌相机的封装（这是必要的）之外，在使用方的代码中还要添加新的条件分支来支持对新品牌相机的操作，这违反了设计原则中的开放封闭原则。</p>
<p>为了避免上述情况，提供方可以将相机实例化的过程封装到一个类中，这个类的职责就是根据传入的参数来实例化具体的相机对象，这样使用方就无需关心相机对象的创建过程了，在有新的相机品牌加入时，使用方的代码也不会变动。</p>
<p>按照这个思路，就有了简单工厂模式，而这个负责创建相机对象的类就是简单工厂类。</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单工厂模式是工厂模式中的一个便捷实现，是通过一个单一的静态方法来创建不同类型的对象，根据传入参数的不同，可以返回不同类的实例。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>抽象相机类（接口类）：CameraDevice<br>具体相机类：BaslerCameraDevice，SickCameraDevice，HuarayCameraDevice</p>
<p>简单工厂类：CameraDeviceFactory</p>
<p>UML类图如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/design-pattern-2-simple-factory/uml.png"
                     
                ></p>
<p>代码如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CameraDevice</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CameraDevice</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CameraDevice</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">OpenDevice</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaslerCameraDevice</span> : <span class="keyword">public</span> CameraDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">BaslerCameraDevice</span>() <span class="keyword">override</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenDevice</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuarayCameraDevice</span> : <span class="keyword">public</span> CameraDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">HuarayCameraDevice</span>() <span class="keyword">override</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenDevice</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SickCameraDevice</span> : <span class="keyword">public</span> CameraDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SickCameraDevice</span>() <span class="keyword">override</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OpenDevice</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CameraDeviceFactory</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;CameraDevice&gt; <span class="title">CreateCamera</span><span class="params">(std::string vendor_name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vendor_name == <span class="string">&quot;Basler&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;BaslerCameraDevice&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vendor_name == <span class="string">&quot;Huaray&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;HuarayCameraDevice&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vendor_name == <span class="string">&quot;Sick&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;SickCameraDevice&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string vendor_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> camera = CameraDeviceFactory::<span class="built_in">CreateCamera</span>(vendor_name);</span><br><span class="line">    <span class="keyword">if</span> (camera == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    camera-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    camera-&gt;<span class="built_in">OpenDevice</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><strong>调用简单</strong>：将对象的创建逻辑集中到了简单工厂类中，客户端只需要与工厂类进行交互，而无需关注具体对象的创建过程，降低了客户端代码的复杂性。</li>
<li><strong>解耦</strong>：客户端代码与具体对象解耦，可以通过工厂类创建不同的对象，而无需修改客户端代码，提高了代码的灵活性和可扩展性。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li><strong>违反开闭原则</strong>：对于提供方，每新增具体产品，都需要修改工厂类的内部代码，更新创建逻辑，违反了开闭原则。</li>
<li><strong>扩展困难</strong>：若产品创建的过程复杂，当产品种类增多可能导致工厂类的代码过于臃肿，不宜与扩展和维护。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li><strong>产品类型相对固定</strong>：当系统中的对象种类不多且不经常变化时，使用简单工厂模式非常合适。因为在这种情况下，向工厂类添加新的产品类型并不频繁，也就不会经常违反开闭原则。</li>
<li><strong>隐藏对象创建细节</strong>：当客户端只是需要产品的接口而不关心具体实现时，简单工厂可以隐藏对象的创建细节，客户端只需通过工厂接口请求其需要的对象即可，而无需关心对象是如何被创建、组装的。</li>
<li><strong>对象创建过程简单</strong>：当需要创建的对象逻辑比较简单，不涉及复杂的条件判断或算法时，可以使用简单工厂模式</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a class="link"   href="https://www.cnblogs.com/lifegoeson/p/13474404.html" >设计模式：工厂设计模式介绍及3种写法（简单工厂、工厂方法、抽象工厂）
 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++设计模式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多态学习（二）菱形继承</title>
    <url>/2023/12/06/diamond-inherit/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在前一篇笔记<a class="link"   href="https://blog.csdn.net/weixin_44727495/article/details/134635343" >C++多态学习（一）单继承与多重继承 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中讨论了单继承和多重继承，本文将针对菱形继承进行讨论</p>
<h1 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h1><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base的this指针是:%p!\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> b;    <span class="comment">//4字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base1的this指针是:%p!\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//虚表指针8字节</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::func3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> b1;    <span class="comment">//4字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base2的this指针是:%p!\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::func4&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Derive的this指针是:%p!\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::func4&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::func3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func5</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::func5&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/12/06/diamond-inherit/diamond_inherit.png"
                     
                ></p>
<h2 id="基类冗余"><a href="#基类冗余" class="headerlink" title="基类冗余"></a>基类冗余</h2><p>我们知道<code>Derived</code>继承自<code>Base1</code>和<code>Base2</code>，而<code>Base1</code>和<code>Base2</code>又继承自<code>Base</code>。这意味着<code>Derived</code>的内存布局中会有两份<code>Base</code>的拷贝。这会引起数据的不一致性和资源的浪费。</p>
<h2 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Derived obj;</span><br><span class="line">obj.b = <span class="number">1</span>;    <span class="comment">//Derived::b不明确</span></span><br><span class="line">Base* p = &amp;obj;    <span class="comment">//基类Base不明确</span></span><br></pre></td></tr></table></figure></div>
<p>对于<code>obj.b</code>，编译器无法确定在通过<code>Dervide</code>访问<code>Base</code>的成员<code>b</code>时应该选择哪条路径。<br>对于<code>Base* p = &amp;obj</code>，编译器无法确定<code>p</code>应该指向通过<code>Derived1</code>继承的<code>Base</code>还是通过<code>Derived2</code>继承的<code>Base</code>。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文简单讨论了菱形继承的内存布局以及其可能导致的问题。针对上述问题，可以采用虚继承解决，虚继承将在下一篇笔记中讨论。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a class="link"   href="https://ww2.ii.uj.edu.pl/~kapela/pn/cpp_vtable.html" >VTable Notes on Multiple Inheritance in GCC C++ Compiler v4.0.1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++语法</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习——迁移单一仓库至其他代码托管平台</title>
    <url>/2024/05/10/git-code-migration/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>因需迁移单一代码仓库至其他代码托管平台，要迁移的包括仓库内容以及所有历史记录和推送日志。</p>
<p>本文中的方法同样适用于在同一代码托管平台中克隆仓库。</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><strong>1. 创建新仓库：</strong><br>在目的平台的指定位置创建一个新的仓库（目的仓库），用于接收克隆的数据。</p>
<p><strong>2. 克隆旧仓库到本地：</strong><br>将待迁移仓库（旧仓库）克隆到本地。要确保使用带有<code>--mirror</code>的克隆命令，因为这样可以克隆仓库的所有数据，包括所有分支、标签、提交历史等</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --mirror 旧仓库的克隆URL</span><br></pre></td></tr></table></figure></div>

<p><strong>3. 将本地克隆推送至新仓库：</strong><br>进入本地克隆的仓库的目录，然后更改远程推送地址至目的仓库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin 新仓库的克隆URL</span><br></pre></td></tr></table></figure></div>
<p>然后使用push命令将所有数据推送至目的仓库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git push --mirror</span><br></pre></td></tr></table></figure></div>
<p><strong>4. 验证新仓库</strong></p>
<p>在目标平台中查看新仓库，确认所有的分支、标签和提交历史都已正确推送。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上步骤，可以将一个完整的仓库迁移到其他平台或相同平台的不同路径。这样做不仅复制了代码，还包括了完整的推送日志和版本历史，使得新仓库成为旧仓库的完整镜像。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>Centos8系统启动时间优化</title>
    <url>/2024/05/16/linux-centos-boot-time-optimization/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因需要，对Centos8操作系统的启动时间进行优化。</p>
<h1 id="初始化系统"><a href="#初始化系统" class="headerlink" title="初始化系统"></a>初始化系统</h1><p>Centos8使用了systemd作为系统和服务管理器。systemd是现代Linux发行版中普遍采用的初始化系统，它负责在启动时初始化系统环境并管理系统服务。我们在分析操作系统的启动过程时可以使用<code>systemd</code>和<code>systemctl</code>相关的命令。</p>
<h1 id="启动阶段"><a href="#启动阶段" class="headerlink" title="启动阶段"></a>启动阶段</h1><p>首先查看操作系统启动过程中各阶段的耗时信息：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemd-analyze</span><br></pre></td></tr></table></figure></div>
<p>显示</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">Startup finished in 4.401s (firmware) + 10.322s (loader) + 1.121s (kernel) + 5.921s (initrd) + 36.591s (userspace) = 58.357s</span><br></pre></td></tr></table></figure></div>
<p>我们可以看到系统启动分为了五个阶段：</p>
<ul>
<li>**firmware(固件)**：这个阶段包括BIOS或UEFI启动之前的时间。这是硬件自检和准备启动操作系统之前的时间。</li>
<li>**loader(加载器)**：这是引导加载器的时间，例如GRUB。这个阶段是从BIOS传递到引导加载器，再从引导加载器开始加载操作系统。</li>
<li>**kernel(内核)**：这代表Linux内核的加载和初始化时间。内核配置和硬件驱动加载都发生在这个阶段。</li>
<li>**initrd(初始RAM磁盘)**：这是初始内存文件系统的加载和执行时间。它通常包含一些必要的驱动和系统文件，用来帮助内核挂载真实的根文件系统。</li>
<li>**userspace(用户空间)**：这是启动所有用户空间服务的时间。这个阶段的时间取决于你的系统上有哪些服务和程序被配置为启动。</li>
</ul>
<p>下面来按阶段分析可能的优化手段</p>
<h2 id="firmware-固件"><a href="#firmware-固件" class="headerlink" title="firmware(固件)"></a>firmware(固件)</h2><p>优化固件启动时间通常比较麻烦，因为设计到硬件级别的操作：调整BIOS或UEFI的设置等。以下是一些可以尝试的方法：</p>
<ul>
<li><strong>禁用不必要的启动选项</strong>：在BIOS&#x2F;UEFI设置中，你可以禁用一些不常用的设备启动选项，比如网络启动（PXE Boot）或其他外部设备。这样可以减少固件搜索和初始化设备的时间。</li>
<li><strong>快速启动</strong>：许多现代BIOS&#x2F;UEFI提供了“快速启动”（Fast Boot）或“快速启动”（Quick Boot）选项。启用这些选项可以让固件跳过某些自检程序（POST），从而缩短启动时间。</li>
<li><strong>更新固件</strong>：硬件制造商有时会发布更新以改善性能和减少启动时间。</li>
<li><strong>启动顺序</strong>：调整启动顺序，首选从主硬盘启动，而不是像usb这样的外部设备。这样可以减少固件在尝试从未使用设备启动时花费的时间。</li>
<li><strong>优化安全设置</strong>：安全启动（Secure Boot）和其他安全检查可能会增加启动时间。如果不需要这些额外的安全措施，可以考虑禁用它们。</li>
</ul>
<p>对于我的设备，在firmware阶段可做的优化选择很少而且收益不高，因此我在此阶段没有做相关的优化。</p>
<h2 id="loader-加载器"><a href="#loader-加载器" class="headerlink" title="loader(加载器)"></a>loader(加载器)</h2><p>优化loader阶段的启动时间主要涉及配置和优化引导加载程序。以下是一些可以减少loader阶段启动时间的方法：</p>
<ul>
<li><strong>优化GRUB</strong>：编辑GRUB配置文件（&#x2F;etc&#x2F;default&#x2F;grub），减少启动菜单的等待时间（默认为5秒）。例如，将GRUB_TIMEOUT设置为更短的时间（如1秒），甚至设置为0以直接跳过菜单。修改完毕后使用<code>grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg</code>使更改生效</li>
</ul>
<p>对于我的设备，每天都要进行上电自启动，而且上电后是无人操作的，所以可以在此阶段优化启动时间。我设置的等待时间为1秒，相较于默认的5秒，缩短了4秒。</p>
<h2 id="kernel-内核"><a href="#kernel-内核" class="headerlink" title="kernel(内核)"></a>kernel(内核)</h2><p>优化Linux系统中kernel阶段的启动时间主要涉及减少内核加载和初始化所需时间。这可以通过精简内核、优化内核配置和调整启动参数等来实现：</p>
<ul>
<li><strong>编译定制内核</strong>：如果默认的内核包含很多不需要的驱动和模块，可以考虑自己编译一个精简版的内核。只包括必要的驱动和模块可以显著减少内核的启动时间。</li>
<li><strong>使用内核启动参数</strong>：通过修改GRUB中的内核启动参数来优化启动过程。例如，添加quiet参数可以减少启动时的日志输出，profile&#x3D;2可以在系统启动后重新生成读取文件的优化列表，从而加速后续的启动。</li>
<li><strong>禁用不必要的内核功能</strong>：通过内核配置，禁用不需要的功能如调试功能、不使用的文件系统类型、不必要的硬件支持等。</li>
<li><strong>内核启动剖析</strong>：使用内核启动剖析工具，如printk时间戳和initcall_debug内核参数，来监控和识别内核启动过程中的延迟瓶颈。</li>
</ul>
<p>对于我的设备，在kernel阶段优化的收益不高，因此我在此阶段没有做相关的优化。</p>
<h2 id="initrd-初始RAM磁盘"><a href="#initrd-初始RAM磁盘" class="headerlink" title="initrd(初始RAM磁盘)"></a>initrd(初始RAM磁盘)</h2><p>优化Linux系统中的initrd（初始内存盘）阶段的启动时间可以通过减少initrd的大小、精简其内容，以及优化其加载过程来实现：</p>
<ul>
<li><strong>精简initrd内容</strong>：initrd包含了系统启动所需的最小集合的驱动和文件系统工具。如果initrd中包含了不必要的驱动或模块，可以在构建initrd时移这些模块。</li>
<li><strong>压缩initrd</strong>：initrd通常使用压缩来减少其在磁盘上的大小，从而提高加载速度。适当选择如gzip、xz或lz4等压缩算法，可以提高启动速度。</li>
</ul>
<p>对于这一阶段不太了解，故没有选择针对此阶段进行优化。</p>
<h2 id="userspace-用户空间"><a href="#userspace-用户空间" class="headerlink" title="userspace(用户空间)"></a>userspace(用户空间)</h2><p>优化Linux系统中的用户空间（userspace）阶段启动时间可以显著改善整体启动体验。用户空间启动阶段是指内核启动之后，系统启动各种服务和应用程序的阶段，可以使用下述方法优化：</p>
<ul>
<li><p><strong>分析服务启动时间并禁用非必要的服务</strong>：使用<code>systemd-analyze blame</code>查看启动过程中每个服务的耗时，根据具体情况确定哪些服务是非常耗时且非必要的，使用<code>systemctl disable xxxservicenamexxx</code>禁用这些服务以加速启动过程。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/16/linux-centos-boot-time-optimization/result.png"
                     
                ></p>
</li>
<li><p><strong>延迟启动服务</strong>：对于不需要在启动时立即运行的服务，可以配置它们延迟启动或按需启动。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在测试中，我只是将GRUB菜单等待时间从5秒缩减到1秒，并禁用了一些用户空间阶段启动的服务，并未针对firmware、kernel、initrd阶段进行优化。</p>
<p>但是目前可能是因为有某些进程未启动完毕，如果不手动<code>systemctl cancel</code>服务，那么它就会一直被统计到userspace的耗时中。</p>
<p>优化后的结果如下：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">Startup finished in 4.386s (firmware) + 6.145s (loader) + 1.119s (kernel) + 3.525s (initrd) + 17min 4.058s (userspace) = 17min 19.235s</span><br></pre></td></tr></table></figure></div>
<p>多次测试后发现firmware和kernel阶段的耗时很稳定，每次的偏差的不多；loader阶段也很稳定，而且由之前的10秒降为6秒左右，证明优化是起作用的；而initrd阶段的耗时会在3.5-6.5秒之间横跳，目前不知道变化的原因；userspace阶段由于未知服务，对耗时统计影响较大，待后期排查原因。</p>
<p>本笔记后面持续更新。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux操作</category>
      </categories>
  </entry>
  <entry>
    <title>使用update-alternatives管理GCC版本</title>
    <url>/2024/07/29/linux-update-alternatives/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当操作系统中存在多个版本的GCC时，可以使用使用<code>update-alternatives</code>管理默认使用的编译器版本。</p>
<p>本文使用<code>gcc-9</code>和<code>gcc-11</code>做演示，操作系统为<code>ubuntu-20.04</code></p>
<h1 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h1><p><strong>①使用以下命令确认<code>gcc</code>已正确安装</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc-9 --version</span><br><span class="line">gcc-11 --version</span><br></pre></td></tr></table></figure></div>
<p><strong>②使用以下命令查看已配置的<code>gcc</code>版本</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">update-alternatives --display gcc</span><br></pre></td></tr></table></figure></div>
<p>没有配置过应该输出如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/linux-update-alternatives/result.png"
                     
                ></p>
<p><strong>③添加版本到update-alternatives</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90</span><br><span class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 110</span><br></pre></td></tr></table></figure></div>
<p>这里的90和110是指定的优先级。</p>
<p>④<strong>配置默认<code>gcc</code>版本</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">update-alternatives --config gcc</span><br></pre></td></tr></table></figure></div>
<p>执行此命令后，系统将提供一个选择列表，我们可以选择默认的<code>gcc</code>版本<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/linux-update-alternatives/gcc_version.png"
                     
                ></p>
<p>我这里优先级最大的<code>gcc-11</code>被自动选为了默认版本，我们直接输入回车选择它就可以（具体的要根据你的实际情况进行选择）</p>
<p>⑤<strong>验证更改</strong><br>运行以下命令确认更改生效，显示的版本应该与你选择的相符</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/29/linux-update-alternatives/confirm.png"
                     
                ></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux操作</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS8系统网口桥接</title>
    <url>/2024/03/04/network-bridging/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>因需要，对主板两个网口进行桥接。</p>
<h1 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h1><p>主板型号：Gigabyte GA-IMB370TN<br>操作系统：CentOS 8.2</p>
<h1 id="桥接步骤"><a href="#桥接步骤" class="headerlink" title="桥接步骤"></a>桥接步骤</h1><h2 id="清除旧配置"><a href="#清除旧配置" class="headerlink" title="清除旧配置"></a>清除旧配置</h2><p>先备份旧的网络配置文件，然后将其清除。<br>网络配置文件的位置如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/sysconfig/network-scripts</span><br></pre></td></tr></table></figure></div>
<p>网络配置文件：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/04/network-bridging/net_config.png"
                      alt="网络配置文件"
                ><figcaption>网络配置文件</figcaption></figure></p>
<h2 id="查看网口名称"><a href="#查看网口名称" class="headerlink" title="查看网口名称"></a>查看网口名称</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con show</span><br></pre></td></tr></table></figure></div>
<p>我的两个网口名称分别为：eno1和enp3s0<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/04/network-bridging/port_name.png"
                      alt="网口名称"
                ><figcaption>网口名称</figcaption></figure></p>
<h2 id="建立网桥"><a href="#建立网桥" class="headerlink" title="建立网桥"></a>建立网桥</h2><p>创建一个新的桥接连接，其名为br0，设置其ipv4地址为：xxx.xxx.xxx.xxx（如192.168.23.23），子网掩码为：255.255.255.0，并设置为自动连接。<br>br0将eno1和enp3s0作为从属接口，这允许两个网络接口（eno1和enp3s0）在同一个桥接网络内可以相互通信，同时这个桥接还可以与其他设备或网络通信</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con add <span class="built_in">type</span> bridge autoconnect <span class="built_in">yes</span> con-name br0 ifname br0</span><br><span class="line">nmcli con add <span class="built_in">type</span> bridge-slave autoconnect <span class="built_in">yes</span> con-name br-eno1 ifname eno1 master br0</span><br><span class="line">nmcli con add <span class="built_in">type</span> bridge-slave autoconnect <span class="built_in">yes</span> con-name br-enp3s0 ifname enp3s0 master br0</span><br><span class="line">nmcli con modify br0 ipv4.addresses xxx.xxx.xxx.xxx/24</span><br><span class="line">nmcli con modify br0 ipv4.method manual</span><br><span class="line">nmcli con up br0</span><br></pre></td></tr></table></figure></div>
<p>操作结果：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/04/network-bridging/result.png"
                      alt="桥接操作结果"
                ><figcaption>桥接操作结果</figcaption></figure><br>此时，网络配置文件有三个：<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/04/network-bridging/net_config2.png"
                      alt="网络配置文件2"
                ><figcaption>网络配置文件2</figcaption></figure></p>
<h2 id="查看是否桥接成功"><a href="#查看是否桥接成功" class="headerlink" title="查看是否桥接成功"></a>查看是否桥接成功</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con show</span><br></pre></td></tr></table></figure></div>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/04/network-bridging/result2.png"
                      alt="在这里插入图片描述"
                ><figcaption>在这里插入图片描述</figcaption></figure><br>当然也可以使用另一台设备去连接这两个网口，若使用两个网口都可以连接到设置的ip：xxx.xxx.xxx.xxx。则证明操作成功。</p>
<p><strong>至此网络桥接已操作完成</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux操作</category>
      </categories>
  </entry>
  <entry>
    <title>C++智能指针学习——小谈引用计数</title>
    <url>/2024/04/07/reference-counting/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文结合源码讨论std::shared_ptr和std::weak_ptr的部分底层实现，然后讨论引用计数，弱引用计数的创建和增减。<br>文章中尽可能的先阐述原理，然后再贴上代码。如果有不想看代码的，直接略过代码即可。<br>本文涉及的源码均出自gcc 9.4.0版本</p>
<h1 id="控制块简介"><a href="#控制块简介" class="headerlink" title="控制块简介"></a>控制块简介</h1><p>控制块是<code>shared_ptr</code>和<code>weak_ptr</code>中的重要组成，主要用于管理资源的引用计数和生命周期。这个机制允许智能指针安全地共享和管理同一个对象，同时自动释放不再需要的资源。</p>
<p>控制块包含以下部分：</p>
<ul>
<li>引用计数</li>
<li>弱引用计数</li>
<li>分配器</li>
<li>删除器</li>
</ul>
<p>本文讨论的引用计数和弱引用计数的创建、加减、销毁，与控制块密切相关。</p>
<h1 id="共享控制块"><a href="#共享控制块" class="headerlink" title="共享控制块"></a>共享控制块</h1><p>首先我们要知道，当创建一个<code>std::shared_ptr</code>指向某个对象时，会生成一个控制块来存储该对象的引用计数和其他管理信息。如果基于这个<code>std::shared_ptr</code>再创建一个或多个<code>std::weak_ptr</code>，那么这些<code>std::weak_ptr</code>将也指向这个控制块。</p>
<p>示意图大概长这样：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/04/07/reference-counting/ctr_block.png"
                     
                ></p>
<h1 id="引用计数与弱引用计数创建过程"><a href="#引用计数与弱引用计数创建过程" class="headerlink" title="引用计数与弱引用计数创建过程"></a>引用计数与弱引用计数创建过程</h1><p>在谈引用计数和弱引用计数的创建时，其实就是讨论控制块的创建。</p>
<p>我们知道<code>std::weak_ptr</code>是被设计用来解决<code>std::shared_ptr</code>智能指针可能导致的循环引用问题。一个有效的<code>std::weak_ptr</code>对象一般是通过<code>std::shared_ptr</code>构造的或者是通过拷贝（移动）其他<code>std::weak_ptr</code>对象得到的，<code>std::weak_ptr</code>对象的构造不涉及控制块的创建。</p>
<p>因此在讨论引用计数、弱引用计数的创建时，我们是去分析<code>std::shared_ptr</code>的源码</p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="__shared_ptr"></a>__shared_ptr</h2><p><code>__shared_ptr</code>是<code>std::shared_ptr</code>的核心实现，它位于<code>shared_ptr_base.h</code>中。</p>
<p><code>__shared_ptr</code>在构造实例时都会构造一个<code>_M_refcount</code>，它的类型为<code>__shared_count&lt;_Lp&gt;</code>。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: shared_ptr_base.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_ptr</span> : <span class="keyword">public</span> __shared_ptr_access&lt;_Tp, _Lp&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> element_type = <span class="keyword">typename</span> remove_extent&lt;_Tp&gt;::type;</span><br><span class="line">	<span class="comment">//默认构造</span></span><br><span class="line">	<span class="keyword">constexpr</span> __shared_ptr() <span class="keyword">noexcept</span></span><br><span class="line">      : _M_ptr(<span class="number">0</span>), _M_refcount()</span><br><span class="line">      &#123; &#125;</span><br><span class="line">	...	</span><br><span class="line">	<span class="comment">//有删除器和分配器的构造</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Yp, <span class="keyword">typename</span> _Deleter, <span class="keyword">typename</span> _Alloc,</span><br><span class="line">	       <span class="keyword">typename</span> = _SafeConv&lt;_Yp&gt;&gt;</span><br><span class="line">	__shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)</span><br><span class="line">	: _M_ptr(__p), _M_refcount(__p, std::<span class="built_in">move</span>(__d), std::<span class="built_in">move</span>(__a))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">static_assert</span>(__is_invocable&lt;_Deleter&amp;, _Yp*&amp;&gt;::value,</span><br><span class="line">	      <span class="string">&quot;deleter expression d(p) is well-formed&quot;</span>);</span><br><span class="line">	  _M_enable_shared_from_this_with(__p);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">	element_type*        _M_ptr;         <span class="comment">// Contained pointer.</span></span><br><span class="line">    __shared_count&lt;_Lp&gt;  _M_refcount;    <span class="comment">// Reference counter.	</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="shared-count"><a href="#shared-count" class="headerlink" title="__shared_count"></a>__shared_count</h2><p>在创建<code>__shared_count</code>对象时，也会创建一个指向控制块的指针（<code>_Sp_counted_base</code>类型的指针）。控制块用来管理引用计数。</p>
<p>代码中的<code>_Sp_counted_ptr</code>和<code>_Sp_counted_deleter</code>就是<code>_Sp_counted_base</code>的派生类。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: shared_ptr_base.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_count</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认构造</span></span><br><span class="line">	__shared_count(_Ptr __p) : _M_pi(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    __try</span><br><span class="line">	    &#123;</span><br><span class="line">	        _M_pi = <span class="keyword">new</span> _Sp_counted_ptr&lt;_Ptr, _Lp&gt;(__p);</span><br><span class="line">	    &#125;</span><br><span class="line">	    __catch(...)</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">delete</span> __p;</span><br><span class="line">	        __throw_exception_again;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//带分配器和删除器的构造</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span> _Deleter, <span class="keyword">typename</span> _Alloc,</span><br><span class="line">	       <span class="keyword">typename</span> = <span class="keyword">typename</span> __not_alloc_shared_tag&lt;_Deleter&gt;::type&gt;</span><br><span class="line">	__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">typedef</span> _Sp_counted_deleter&lt;_Ptr, _Deleter, _Alloc, _Lp&gt; _Sp_cd_type;</span><br><span class="line">	    __try</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">typename</span> _Sp_cd_type::__allocator_type __a2(__a);</span><br><span class="line">	        <span class="keyword">auto</span> __guard = std::__allocate_guarded(__a2);</span><br><span class="line">	        _Sp_cd_type* __mem = __guard.<span class="built_in">get</span>();</span><br><span class="line">	        ::<span class="keyword">new</span> (__mem) _Sp_cd_type(__p, std::<span class="built_in">move</span>(__d), std::<span class="built_in">move</span>(__a));</span><br><span class="line">	        _M_pi = __mem;</span><br><span class="line">	        __guard = <span class="literal">nullptr</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    __catch(...)</span><br><span class="line">	    &#123;</span><br><span class="line">	        __d(__p); <span class="comment">// Call _Deleter on __p.</span></span><br><span class="line">	        __throw_exception_again;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">__weak_count</span>&lt;_Lp&gt;;</span><br><span class="line">	_Sp_counted_base&lt;_Lp&gt;*  _M_pi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="Sp-counted-base"><a href="#Sp-counted-base" class="headerlink" title="_Sp_counted_base"></a>_Sp_counted_base</h2><p><code>_Sp_counted_base</code>负责管理引用计数和弱引用计数，其中</p>
<ul>
<li><code>_M_use_count</code>是<code>shared_ptr</code>的计数，就是引用计数，表示有多少个<code>shared_ptr</code>对象共享同一个内存资源。</li>
<li><code>_M_weak_count</code>是<code>weak_ptr</code>的计数，也就是弱引用计数，表示有多少个<code>weak_ptr</code>对象引用同一个资源。</li>
</ul>
<p>我们可以看到在<code>_Sp_counted_base</code>的初始化列表中，初始化了<code>_M_use_count</code>和<code>_M_weak_count</code>为1，完成了引用计数和弱引用计数的创建和初始化。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: shared_ptr_base.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;</span><br><span class="line"><span class="keyword">class</span> _Sp_counted_base : <span class="keyword">public</span> _Mutex_base&lt;_Lp&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _Sp_counted_base() <span class="keyword">noexcept</span> : _M_use_count(<span class="number">1</span>), _M_weak_count(<span class="number">1</span>) &#123; &#125;</span><br><span class="line">	...	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	_Atomic_word  _M_use_count;     <span class="comment">// #shared</span></span><br><span class="line">	_Atomic_word  _M_weak_count;    <span class="comment">// #weak + (#shared != 0)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这里再简单提一下<code>_Sp_counted_base</code>、<code>_Sp_counted_ptr</code>和<code>_Sp_counted_deleter</code>的关系与各自的功能。</p>
<ul>
<li><code>_Sp_counted_base</code>是一个抽象基类，定义并管理了引用计数与弱引用记数。</li>
<li><code>_Sp_counted_ptr</code>继承自<code>_Sp_counted_base</code>，主要是使用默认的分配策略和删除策略管理资源对象。</li>
<li><code>_Sp_counted_deleter</code>继承自<code>_Sp_counted_base</code>，主要是使用用户提供的分配器和删除器管理资源对象。</li>
</ul>
<p>因为<code>_Sp_counted_base</code>是抽象基类无法被实例化，所以使用的是其派生类<code>_Sp_counted_ptr</code>和<code>_Sp_counted_deleter</code>对象来管理引用计数、弱引用计数、分配器、删除器。这个对象就是我们常说的控制块。</p>
<p>（<code>_Sp_counted_base</code>还有一个派生类<code>_Sp_counted_ptr_inplace</code>，适合使用<code>std::make_shared</code>的场景，此处不过多讨论）</p>
<h1 id="弱引用计数增加过程"><a href="#弱引用计数增加过程" class="headerlink" title="弱引用计数增加过程"></a>弱引用计数增加过程</h1><h2 id="再谈共享控制块"><a href="#再谈共享控制块" class="headerlink" title="再谈共享控制块"></a>再谈共享控制块</h2><p>在上面的引用计数与弱引用计数创建过程中，我们提到：</p>
<blockquote>
<p>一个有效的<code>std::weak_ptr</code>对象一般是通过<code>std::shared_ptr</code>构造的或者是通过拷贝（移动）其他<code>std::weak_ptr</code>对象得到的</p>
</blockquote>
<p>对应的<code>__weak_count</code>和<code>__shared_count</code>对象也具有上述关系。</p>
<p>查看源码，我们可以发现，<code>__weak_count</code>和<code>__shared_count</code>都有一个指向控制块的多态指针。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">_Sp_counted_base&lt;_Lp&gt;*  _M_pi;</span><br></pre></td></tr></table></figure></div>
<p>在<code>__weak_count</code>中并没有使用<code>new</code>或者类似操作让<code>_M_pi</code>指向一块新的内存（控制块）。追根溯源，<code>__weak_count</code>中多态指针指向的控制块的来源就是<code>__shared_count</code>。代码中是通过在<code>__weak_count</code>构造函数和重载的赋值运算符中给多态指针<code>_M_pi</code>初始化和赋值实现的。以此实现了<code>weak_ptr</code>和<code>shared_ptr</code>共享控制块的功能。</p>
<h2 id="weak-count"><a href="#weak-count" class="headerlink" title="__weak_count"></a>__weak_count</h2><p>弱引用计数的增加可以分为下面几种情况:</p>
<ul>
<li>通过<code>std::shared_ptr</code>构造<code>std::weak_ptr</code></li>
<li>通过<code>std::weak_ptr</code>构造<code>std::weak_ptr</code></li>
<li>通过<code>std::shared_ptr</code>给<code>std::weak_ptr</code>赋值</li>
<li>通过<code>std::weak_ptr</code>给<code>std::weak_ptr</code>赋值</li>
</ul>
<p>其实本质是靠调用<code>_M_weak_add_ref()</code>增加的弱引用计数，详情见<code>__weak_count</code>的源码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: shared_ptr_base.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__weak_count</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//通过__shared_count构造</span></span><br><span class="line">    <span class="comment">//和一个已存在的__shared_count对象共享控制块，并更新控制块的弱引用计数</span></span><br><span class="line">    __weak_count(<span class="type">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">     : _M_pi(__r._M_pi)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//若入参的多态指针不为空</span></span><br><span class="line">        <span class="comment">//弱引用计数++（增加_Sp_counted_base对象的_M_weak_count）</span></span><br><span class="line">		<span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">			_M_pi-&gt;_M_weak_add_ref();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//通过__weak_count拷贝构造</span></span><br><span class="line">    <span class="comment">//和传入的__weak_count对象就共享同一个控制块，并更新控制块的弱引用计数</span></span><br><span class="line">    __weak_count(<span class="type">const</span> __weak_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">     : _M_pi(__r._M_pi)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">			_M_pi-&gt;_M_weak_add_ref();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//通过__shared_count给__weak_count赋值</span></span><br><span class="line">	__weak_count&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">    	_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    	<span class="comment">//新对象弱引用计数++</span></span><br><span class="line">		<span class="keyword">if</span> (__tmp != <span class="literal">nullptr</span>)</span><br><span class="line">	  		__tmp-&gt;_M_weak_add_ref();</span><br><span class="line">	  	<span class="comment">//原对象弱引用计数--</span></span><br><span class="line">		<span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">	  		_M_pi-&gt;_M_weak_release();</span><br><span class="line">	  	<span class="comment">//指向新对象的控制块</span></span><br><span class="line">		_M_pi = __tmp;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过__weak_count给__weak_count赋值</span></span><br><span class="line">	__weak_count&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __weak_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">		_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">		<span class="keyword">if</span> (__tmp != <span class="literal">nullptr</span>)</span><br><span class="line">	  		__tmp-&gt;_M_weak_add_ref();</span><br><span class="line">		<span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">	  		_M_pi-&gt;_M_weak_release();</span><br><span class="line">		_M_pi = __tmp;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">__shared_count</span>&lt;_Lp&gt;;</span><br><span class="line">	_Sp_counted_base&lt;_Lp&gt;*  _M_pi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h1 id="引用计数增加过程"><a href="#引用计数增加过程" class="headerlink" title="引用计数增加过程"></a>引用计数增加过程</h1><p>引用计数的增加可以分为下面几种情况:</p>
<ul>
<li>通过<code>std::shared_ptr</code>构造<code>std::shared_ptr</code></li>
<li>通过<code>std::shared_ptr</code>给<code>std::shared_ptr</code>赋值</li>
<li><code>std::weak_ptr</code>升级为<code>std::shared_ptr</code></li>
</ul>
<p>本质是靠调用<code>_M_add_ref_copy()</code>和<code>_M_add_ref_lock</code>增加的引用计数，详情见<code>__shared_count</code>的源码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: shared_ptr_base.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_count</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">    __shared_count(<span class="type">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">     : _M_pi(__r._M_pi)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">			_M_pi-&gt;_M_add_ref_copy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝赋值</span></span><br><span class="line">	__shared_count&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">		_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">		<span class="keyword">if</span> (__tmp != _M_pi)</span><br><span class="line">	  	&#123;</span><br><span class="line">	    	<span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">	      		__tmp-&gt;_M_add_ref_copy();</span><br><span class="line">	    	<span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">	      		_M_pi-&gt;_M_release();</span><br><span class="line">	    	_M_pi = __tmp;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//转换构造</span></span><br><span class="line">	<span class="comment">//weak_ptr使用lock()时会调用此构造函数</span></span><br><span class="line">	<span class="keyword">explicit</span> __shared_count(<span class="type">const</span> __weak_count&lt;_Lp&gt;&amp; __r) </span><br><span class="line">	 : _M_pi(__r._M_pi)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">			_M_pi-&gt;_M_add_ref_lock();<span class="comment">//引用计数++，具体实现依赖于锁策略</span></span><br><span class="line">      	<span class="keyword">else</span></span><br><span class="line">			__throw_bad_weak_ptr();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">__weak_count</span>&lt;_Lp&gt;;</span><br><span class="line">	_Sp_counted_base&lt;_Lp&gt;*  _M_pi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h1 id="弱引用计数的减少过程"><a href="#弱引用计数的减少过程" class="headerlink" title="弱引用计数的减少过程"></a>弱引用计数的减少过程</h1><p>弱引用计数的减少可以分为下面几种情况:</p>
<ul>
<li><code>std::weak_ptr</code>析构</li>
<li><code>std::weak_ptr</code>对象被覆盖（赋值操作覆盖原<code>std::weak_ptr</code>）</li>
</ul>
<p>本质是靠调用<code>_M_weak_release()</code>减少弱引用计数：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: shared_ptr_base.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__weak_count</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~__weak_count() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//转换赋值</span></span><br><span class="line">	__weak_count&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">	&#123;</span><br><span class="line">    	_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">        <span class="keyword">if</span> (__tmp != <span class="literal">nullptr</span>)</span><br><span class="line">          	__tmp-&gt;_M_weak_add_ref();</span><br><span class="line">        <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">        	_M_pi-&gt;_M_weak_release();</span><br><span class="line">        _M_pi = __tmp;</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝赋值</span></span><br><span class="line">	__weak_count&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __weak_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">	&#123;</span><br><span class="line">      	_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">        <span class="keyword">if</span> (__tmp != <span class="literal">nullptr</span>)</span><br><span class="line">          	__tmp-&gt;_M_weak_add_ref();</span><br><span class="line">        <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">          	_M_pi-&gt;_M_weak_release();</span><br><span class="line">        _M_pi = __tmp;</span><br><span class="line">    	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动赋值</span></span><br><span class="line">    __weak_count&amp; <span class="keyword">operator</span>=(__weak_count&amp;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">        	_M_pi-&gt;_M_weak_release();</span><br><span class="line">      	_M_pi = __r._M_pi;</span><br><span class="line">            __r._M_pi = <span class="literal">nullptr</span>;</span><br><span class="line">      	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">__shared_count</span>&lt;_Lp&gt;;</span><br><span class="line">	_Sp_counted_base&lt;_Lp&gt;*  _M_pi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>然后在这里对<code>std::weak_ptr::reset()</code>说明一下：它是用来重置 <code>std::weak_ptr</code> 的。调用 <code>reset()</code> 会使<code>std::weak_ptr</code>不再指向它原本观察的对象。</p>
<p>它也会减少原对象的弱引用计数（本质是通过调用的析构函数使得弱引用计数减少）</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: shared_ptr_base.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	__weak_ptr().<span class="built_in">swap</span>(*<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="弱引用计数减为0"><a href="#弱引用计数减为0" class="headerlink" title="弱引用计数减为0"></a>弱引用计数减为0</h2><p>在上面提到：弱引用计数的减少是通过调用<code>_M_weak_release()</code>实现的。通过分析<code>_M_weak_release()</code>的代码我们可以知道，<code>_M_weak_release()</code>中主要做了：</p>
<ul>
<li>对弱引用计数做减1操作并</li>
<li>判断弱引用计数减1后是否为0，若为0则调用<code>_M_destroy()</code>删除控制块。<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: shared_ptr_base.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;</span><br><span class="line"><span class="keyword">class</span> _Sp_counted_base : <span class="keyword">public</span> _Mutex_base&lt;_Lp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//控制块的弱引用计数为0时，销毁自身</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _M_destroy() <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//弱引用计数--</span></span><br><span class="line">    <span class="comment">//当弱引用计数变为0，销毁控制块</span></span><br><span class="line">	<span class="type">void</span> _M_weak_release() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// Be race-detector-friendly. For more info see bits/c++config.</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">        <span class="comment">//减少弱引用计数，并返回-1之前的值</span></span><br><span class="line">	    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">        	_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">	        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">	        &#123;</span><br><span class="line">	        <span class="comment">// See _M_release(),</span></span><br><span class="line">	        <span class="comment">// destroy() must observe results of dispose()</span></span><br><span class="line">		    	__atomic_thread_fence (__ATOMIC_ACQ_REL);</span><br><span class="line">	        &#125;</span><br><span class="line">	        _M_destroy();</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="引用计数的减少过程"><a href="#引用计数的减少过程" class="headerlink" title="引用计数的减少过程"></a>引用计数的减少过程</h1><p>引用计数的减少可以分为下面几种情况:</p>
<ul>
<li><code>std::shared_ptr</code>析构</li>
<li><code>std::shared_ptr</code>对象被覆盖（赋值操作覆盖原<code>std::shared_ptr</code>）</li>
</ul>
<p>本质是靠调用<code>_M_release()</code>减少弱引用计数</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: shared_ptr_base.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_count</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~__shared_count() <span class="keyword">noexcept</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">        	_M_pi-&gt;_M_release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝赋值</span></span><br><span class="line">    __shared_count&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">		_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">        <span class="keyword">if</span> (__tmp != _M_pi)</span><br><span class="line">        &#123;</span><br><span class="line">          	<span class="keyword">if</span> (__tmp != <span class="number">0</span>)</span><br><span class="line">            	__tmp-&gt;_M_add_ref_copy();</span><br><span class="line">          	<span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">            	_M_pi-&gt;_M_release();</span><br><span class="line">          	_M_pi = __tmp;</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">__weak_count</span>&lt;_Lp&gt;;</span><br><span class="line">	_Sp_counted_base&lt;_Lp&gt;*  _M_pi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="引用计数减为0"><a href="#引用计数减为0" class="headerlink" title="引用计数减为0"></a>引用计数减为0</h2><p>上面提到：引用计数的减少是通过调用<code>_M_release()</code>实现的。通过分析<code>_M_release()</code>的代码我们可以知道，<code>_M_release()</code>中主要做了</p>
<ul>
<li>对引用计数做减1操作并</li>
<li>判断引用计数减1后是否为0，若为0则调用<code>_M_dispose()</code>释放其所管理的内存资源</li>
<li>若引用计数减1后为0，则还会对弱引用计数做一次减1操作并</li>
<li>判断弱引用计数减1后是否为0，若为0则调用<code>_M_destroy()</code>删除控制块。<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: shared_ptr_base.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;</span><br><span class="line"><span class="keyword">class</span> _Sp_counted_base : <span class="keyword">public</span> _Mutex_base&lt;_Lp&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//当前对象的引用计数为0时，释放管理的资源</span></span><br><span class="line">    <span class="comment">//纯虚函数，取决于释放策略，由派生类实现</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _M_dispose() <span class="keyword">noexcept</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前对象的弱引用计数为0时，销毁自身</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _M_destroy() <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> _M_release() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);</span><br><span class="line">        <span class="comment">//减少引用计数，并返回-1之前的值</span></span><br><span class="line">        <span class="comment">//如果引用计数为0，则释放管理的资源</span></span><br><span class="line">	    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">        	_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);</span><br><span class="line">	        _M_dispose();</span><br><span class="line">          	<span class="comment">// There must be a memory barrier between dispose() and destroy()</span></span><br><span class="line">          	<span class="comment">// to ensure that the effects of dispose() are observed in the</span></span><br><span class="line">          	<span class="comment">// thread that runs destroy().</span></span><br><span class="line">          	<span class="comment">// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html</span></span><br><span class="line">          	<span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">          	&#123;</span><br><span class="line">            	__atomic_thread_fence (__ATOMIC_ACQ_REL);</span><br><span class="line">          	&#125;</span><br><span class="line"></span><br><span class="line">          	<span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">          	_GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">          	<span class="comment">//减少弱引用计数，并返回-1之前的值</span></span><br><span class="line">          	<span class="comment">//如果弱引用计数为0，则销毁控制块自身</span></span><br><span class="line">	        <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">          	&#123;</span><br><span class="line">            	_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">	          	_M_destroy();</span><br><span class="line">          	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
这里再说明一下为什么<code>__shared_count</code>要在引用计数减为0时还要对弱引用计数做减1操作：<br>在<code>__shared_count</code>构造的同时，也会构造一个控制块对象，其中引用计数和<strong>弱引用计数</strong>一同被初始化为1。这意味着，即使最后一个<code>std::weak_ptr</code>被销毁了，但若其对应的<code>std::shared_ptr</code>还至少存在一个，那么弱引用计数就不会被减少至0（代码中的注释也是这么提示的）。</li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: shared_ptr_base.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;</span><br><span class="line"><span class="keyword">class</span> _Sp_counted_base : <span class="keyword">public</span> _Mutex_base&lt;_Lp&gt;</span><br><span class="line">&#123;</span><br><span class="line">	_Atomic_word  _M_use_count;     <span class="comment">// #shared</span></span><br><span class="line">	_Atomic_word  _M_weak_count;    <span class="comment">// #weak + (#shared != 0)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>在<code>std::shared_ptr</code>对象存在的情况下，所有相关<code>std::weak_ptr</code>对象被销毁后，控制块仍存在，且其中的弱引用计数为1，此时在销毁最后一个<code>std::shared_ptr</code>对象时，除了要减少引用计数为0，释放管理的内存资源，还要把最后一个弱引用计数减少为0，销毁控制块。</p>
<p>在<code>std::weak_ptr</code>对象存在的情况下，所有相关<code>std::shared_ptr</code>对象都被销毁后，①<code>std::shared_ptr</code>管理的内存资源会被释放（因为引用计数为0，<code>_M_dispose()</code>被调用）②弱引用计数不为0，控制块仍然存在（直到最后一个<code>std::weak_ptr</code>对象被销毁，控制块才会被销毁）</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a class="link"   href="https://blog.csdn.net/qq_41540355/article/details/123123404" >C++2.0 shared_ptr和weak_ptr深入刨析 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>2.<a class="link"   href="https://zhuanlan.zhihu.com/p/678652955" >智能指针std::weak_ptr <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++语法</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多态学习（一）单继承与多重继承</title>
    <url>/2023/11/28/single-and-multi-inherit/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近在学习虚函数相关的知识，发现理解C++继承在内存中的表现以及多态性在底层的实现原理还是有点必要的，故在此写个小笔记，记录一些小知识点。<br>本文相关测试的机器环境：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">Linux Qcumber 5.4.0-84-generic #94~18.04.1-Ubuntu SMP Thu Aug 26 23:17:46 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure></div>
<p>gcc版本：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)</span><br></pre></td></tr></table></figure></div>
<h1 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h1><p>首先从单一继承开始</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::func3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p><code>Derived</code>继承了<code>Base</code>所有成员变量和函数，并且重写了<code>func1()</code>，<code>Derived</code>对象内存布局应该是这样的：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/11/28/single-and-multi-inherit/single_inherit.png"
                     
                ></p>
<p>对虚函数的调用，比如像这样：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Derived* d_ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">d_ptr-&gt;<span class="built_in">func1</span>();</span><br></pre></td></tr></table></figure></div>
<p>其实是等价于<code>*((d_ptr-&gt;vptr)[0])(d_ptr)</code>：</p>
<ul>
<li><code>d_ptr-&gt;vptr</code>：获取虚表地址；</li>
<li><code>(d_ptr-&gt;vptr)[0]</code>：获取虚表第一个槽的地址；</li>
<li><code>*((d_ptr-&gt;vptr)[0])</code>：解引用，获取Derived虚表上的第一个元素，里面存着<code>Derived::func1()</code>的地址；</li>
<li><code>*((d_ptr-&gt;vptr)[0])(d_ptr)</code>：调用<code>Derived::func1()</code>，并隐式地将this指针传递给<code>Derived::func1()</code>。</li>
</ul>
<p>当然，我们无法访问<code>vptr</code>，因此这种等价只是理论上的，有助于理解底层的原理。</p>
<h2 id="指针向上转型"><a href="#指针向上转型" class="headerlink" title="指针向上转型"></a>指针向上转型</h2><p>在C++多态中，支持父类的指针指向子类的对象：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base* b_ptr = &amp;d;</span><br></pre></td></tr></table></figure></div>
<p>这是因为所有派生类对象都可以视作基类的对象（因为派生类继承了基类的函数和变量），但并非所有基类的对象都可以视作派生类的对象。</p>
<p>如果你有一个<code>Base</code>指针，你可以调用在Base中声明的函数。而如果有一个<code>Derived</code>指针，由于<code>Derived</code>继承了<code>Base</code>的所有函数和变量，因此<code>Derived</code>也能够访问<code>Base</code>的函数和变量。</p>
<p>当使用基类的指针指向派生类对象时，基类指针可访问的部分如下图红框：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/11/28/single-and-multi-inherit/single_inherit2.png"
                     
                ></p>
<p>注意：</p>
<ul>
<li>虚表第一个槽中函数地址已经被替换为<code>Derived::func1()</code>的地址，因此无论是<code>b_ptr-&gt;func1()</code>还是<code>d_ptr-&gt;func1()</code>都会调用<code>Derived::func1()</code>。</li>
</ul>
<h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p>当多重继承时，内存模型就变得稍微复杂一点了;</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base1的this指针是:%p!\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//虚表指针8字节</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> b1;    <span class="comment">//4字节</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base2的this指针是:%p!\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::func3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::func4&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Derive的this指针是:%p!\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::func3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func5</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::func5&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>多重继承中主要关注两个方面：内存布局和虚表</p>
<h2 id="内存布局-1"><a href="#内存布局-1" class="headerlink" title="内存布局"></a>内存布局</h2><p><code>Derived</code>对象内存布局如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/11/28/single-and-multi-inherit/multi_inherit.png"
                     
                ></p>
<p>可以观察到<code>Derived</code>对象的内存布局由上到下依次是：<code>Base1，Base2，Derived</code>。因为在内存布局中，首先是基类按照它们在继承列表中的顺序由上到下排列，然后是派生类。</p>
<h2 id="尾部填充（tail-padding）"><a href="#尾部填充（tail-padding）" class="headerlink" title="尾部填充（tail padding）"></a>尾部填充（tail padding）</h2><p>待补充。</p>
<h2 id="this指针调整"><a href="#this指针调整" class="headerlink" title="this指针调整"></a>this指针调整</h2><p>在C++中，一个对象的 this 指针默认指向该对象的起始地址。this指针可以使成员函数能够知道它们是在为哪个具体的对象实例工作，从而可以访问和修改该对象的成员变量。<br>然而在多重继承中会涉及到this指针的偏移：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base1* pb1 = &amp;d;</span><br><span class="line">Base2* pb2 = &amp;d;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;d的地址&quot;</span>&lt;&lt;&amp;d&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;pb1指向的地址&quot;</span>&lt;&lt;pb1&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;pb2指向的地址&quot;</span>&lt;&lt;pb2&lt;&lt;endl;</span><br></pre></td></tr></table></figure></div>
<p>输出的结果是：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/11/28/single-and-multi-inherit/result.png"
                     
                ><br>可以看到静态类型为<code>Base2*</code>的<code>pb2</code>指向的地址与d的地址并不相同。这是因为在指针向上转换时，对于继承列表中非首位的基类，编译器会自动将对象的this指针进行偏移，然后赋值给基类的指针。在上述例子中，this指针的偏移量为16字节（正好等于<code>sizeof(Base1)</code>），然后将偏移后的地址赋予了<code>pb2</code>。</p>
<p>值得注意的是这种指针偏移现象也会出现在调用函数时：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Derived* d = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">d-&gt;<span class="built_in">func4</span>();</span><br></pre></td></tr></table></figure></div>
<p>当通过指向<code>Derived</code>对象的指针调用<code>func4()</code>时，传入的this指针也会被调整。</p>
<h2 id="虚表指针"><a href="#虚表指针" class="headerlink" title="虚表指针"></a>虚表指针</h2><p>多重继承中的虚表指针和虚表也是要特别注意的。<br>可以观察到内存布局中有两个虚表指针，数量与<code>Derived</code>的直接基类数量相等。</p>
<p>为什么上述例子中要有两个虚表指针呢？<br>因为与单继承不同，<code>Base1</code>和<code>Base2</code>完全独立，他们的虚函数没有顺序关系，即<code>func1()</code>和<code>func3()</code>有着相同的对虚表起始位置的偏移量。不可以按序排在一起。而且<code>Base1</code>和<code>Base2</code>中的成员变量也是无关的。所以使得<code>Base1</code>和<code>Base2</code>在<code>Derived</code>中必须要处于两个不相交的区域中，同时需要有两个虚指针分别对它们虚函数进行索引。</p>
<h2 id="non-virtual-thunk"><a href="#non-virtual-thunk" class="headerlink" title="non-virtual thunk"></a>non-virtual thunk</h2><p>现在我们关注<code>func3()</code>，<code>Derived</code>中重写了<code>Base2</code>的<code>func3()</code>。根据内存布局图，在虚表中，<code>Base2</code>部分的<code>func3()</code>并没有被<code>Derived::func3()</code>覆盖，而是产生了一个non-virtual thunk，真正的<code>Derived::func3()</code>地址被放在了虚表中<code>Derived</code>的部分下。这个non-virtual thunk的本质是根据top_offset调整this指针，然后调用真正的函数。</p>
<p>下面解释一下原因，考虑以下情况：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">Base2* p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">p-&gt;<span class="built_in">func3</span>();</span><br></pre></td></tr></table></figure></div>
<p>我们主要关注的就是两点：①调用正确版本的<code>func3()</code>②传入正确的this指针<br>若仅是要调用正确的<code>func3()</code>，那我们完全可以不用生成non-virtual thunk，直接把将Base2中的<code>&amp;Base2::func3()</code>覆盖为<code>&amp;Derived::func3()</code>即可，但是由于我们期望传入的是指向<code>Derived</code>起始地址的this指针，因此就还需要对this指针进行调整。</p>
<p>由上面的this指针讨论结果可知<code>p</code>指向<code>Derived</code>的<code>Base2</code>部分的起始地址。通过反汇编发现，non-virtual thunk正好将this指针向上调整了16B（<code>sizeof(Base1)</code>），使其指向了正确的位置（<code>Derived</code>的起始地址），然后调用了’真正’的<code>func3（）</code>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/11/28/single-and-multi-inherit/result.png"
                     
                ></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文简单讨论了<br>1.单继承和多重继承下类对象的内存布局<br>2.多态下指针的行为<br>3.non-virtual thunk的实现机制</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a class="link"   href="https://shaharmike.com/cpp/vtable-part2/" >C++ vtables - Part 2 - Multiple Inheritance <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>2.<a class="link"   href="https://ww2.ii.uj.edu.pl/~kapela/pn/cpp_vtable.html" >VTable Notes on Multiple Inheritance in GCC C++ Compiler v4.0.1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>3.<a class="link"   href="https://medium.com/geekculture/c-inheritance-memory-model-eac9eb9c56b5" >C++ Inheritance Memory Model <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++语法</category>
      </categories>
      <tags>
        <tag>Linux,lll</tag>
        <tag>Tools,xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习（一）单例模式补充——单例模式析构</title>
    <url>/2024/03/19/singleton-destruct/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18081803" >《单例模式学习》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中提到了，在单例对象是通过<code>new</code>关键字动态分配在堆上的情况下，当程序退出时，不会通过C++的RAII机制自动调用其析构函数。本文讨论一下这种现象的原因以及解决方法。</p>
<h1 id="无法调用析构函数的原因"><a href="#无法调用析构函数的原因" class="headerlink" title="无法调用析构函数的原因"></a>无法调用析构函数的原因</h1><p>在DCLP（双检查锁模式）中，CSingleton中的<code>instance</code>是一个静态指针变量，被分配在全局&#x2F;静态存储区。而<code>instance</code>所指向的CSingleton实例是通过<code>new</code>创建在堆上的，只能手动调用delete来释放相关资源（对于单例模式这是无法实现的，因为析构函数私有），无法通过RAII释放相关资源。<br>在程序结束时，<code>instance</code>这个指针变量被销毁了，但它所指向的内存空间中的CSingleton对象并没有被显式销毁，而是由操作系统去回收这一块内存（不会调用其析构函数）。然而依赖操作系统来清理资源并不是一个优雅的结束方式，可能会造成文件句柄未关闭、网络连接未断开等资源泄漏。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">CSingleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;)			 = <span class="keyword">delete</span>;</span><br><span class="line">    CSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> CSingleton* instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CSingleton* CSingleton::instance;</span><br><span class="line"></span><br><span class="line"><span class="function">CSingleton* <span class="title">CSingleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == instance)</span><br><span class="line">    &#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == instance)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h1><p>在讨论改进方法时，我们还是倾向于利用C++的RAII机制，而不是手动去控制释放的时机。</p>
<h2 id="内嵌回收类"><a href="#内嵌回收类" class="headerlink" title="内嵌回收类"></a>内嵌回收类</h2><p>我们的单例类对象生命周期的开始是在第一次调用时，结束是在程序结束时。</p>
<p>而且我们知道①静态成员变量的生命周期是从程序启动到结束②在静态成员变量被销毁时会调用其析构函数</p>
<p>因此我们可以在单例类中定义一个用于释放单例类资源的内嵌类，将其析构函数定义为显式删除单例对象的操作，然后在单例类中添加一个内嵌类类型的静态成员变量<code>garbo</code>。</p>
<p>这样的话，在程序结束时<code>garbo</code>就会被销毁，而RAII机制确保了在销毁时会调用内嵌类<code>CGarbo</code>的析构函数。</p>
<p>因为在<code>~CGarbo()</code>中delete了<code>CSingleton::instance</code>，所以<code>~CSingleton()</code>就会被调用，相关资源得以释放。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;创建了一个对象&quot;</span>&lt;&lt; std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;销毁了一个对象&quot;</span>&lt;&lt; std::endl;&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;) 			 = <span class="keyword">delete</span>;</span><br><span class="line">    CSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="type">static</span> CSingleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CGarbo</span>    </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CGarbo</span>()&#123;&#125;</span><br><span class="line">        ~<span class="built_in">CGarbo</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> != CSingleton::instance)    <span class="comment">//嵌套类可访问外层类的私有成员</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> CSingleton::instance;</span><br><span class="line">                instance = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             std::cout&lt;&lt;<span class="string">&quot;Garbo worked&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="type">static</span> CGarbo garbo; <span class="comment">//定义一个静态成员，程序结束时，系统会自动调用它的析构函数</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">CSingleton* CSingleton::instance;</span><br><span class="line"></span><br><span class="line">std::mutex CSingleton::mtx;</span><br><span class="line"></span><br><span class="line"><span class="function">CSingleton* <span class="title">CSingleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSingleton::CGarbo CSingleton::garbo;    <span class="comment">//还需要初始化一个垃圾清理的静态成员变量</span></span><br></pre></td></tr></table></figure></div>
<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/19/singleton-destruct/result_garbo.png"
                     
                ></p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>我们还可以利用智能指针引用计数机制，对资源自动管理：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;CSingleton&gt; <span class="title">getInstance</span><span class="params">()</span></span>; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;创建了一个对象&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;销毁了一个对象&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">    CSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;CSingleton&gt; instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;CSingleton&gt; CSingleton::instance;</span><br><span class="line"></span><br><span class="line">std::mutex CSingleton::mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;CSingleton&gt; <span class="title">CSingleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == instance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == instance)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = std::<span class="built_in">shared_ptr</span>&lt;CSingleton&gt;(<span class="keyword">new</span> <span class="built_in">CSingleton</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意上述代码无法通过编译，原因是当<code>std::shared_ptr</code>被销毁时，它会尝试使用delete来销毁管理的对象。但因为CSingleton的析构函数是私有的，所以无法从外部手动销毁CSingleton实例。</p>
<p>要解决这个问题，我们需要在CSingleton中自定义一个删除器，让<code>std::shared_ptr</code>能够调用私有析构函数。 </p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;CSingleton&gt; <span class="title">getInstance</span><span class="params">()</span></span>; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;创建了一个对象&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;销毁了一个对象&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">    CSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;CSingleton&gt; instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleter</span><span class="params">(CSingleton* p)</span></span>; <span class="comment">//自定义删除器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;CSingleton&gt; CSingleton::instance;</span><br><span class="line"></span><br><span class="line">std::mutex CSingleton::mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;CSingleton&gt; <span class="title">CSingleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == instance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == instance)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = std::<span class="built_in">shared_ptr</span>&lt;CSingleton&gt;(<span class="keyword">new</span> <span class="built_in">CSingleton</span>(),CSingleton::deleter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSingleton::deleter</span><span class="params">(CSingleton* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;deleter worked&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>测试结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/19/singleton-destruct/result_shared_ptr.png"
                     
                ></p>
<h2 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h2><p>局部静态变量形式的单例模式也可以完成资源的释放，详见<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18081803" >《单例模式学习》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> CSingleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> CSingleton instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>C++</category>
        <category>C++设计模式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习（一）单例模式补充——指令重排</title>
    <url>/2024/03/19/singleton-reorder/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18081803" >《单例模式学习》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中曾提到懒汉式DCLP的单例模式实际也不是线程安全的，这是编译器的指令重排导致的，本文就简单讨论一下指令重排对单例模式的影响，以及对应的解决方法。</p>
<h1 id="指令重排简介"><a href="#指令重排简介" class="headerlink" title="指令重排简介"></a>指令重排简介</h1><blockquote>
<p>指令重排（Instruction Reordering）是编译器或处理器为了优化程序执行效率而对程序中的指令序列进行重新排序的过程。这种重排可以发生在编译时也可以发生在运行时，目的是为了减少指令的等待时间和提高执行的并行性。</p>
</blockquote>
<p>指令重排可能会引入并发程序中的一些问题，特别是在多线程环境中，没有适当同步机制的情况下，可能会导致程序的执行结果不符合预期。</p>
<p>下面介绍指令重排在单例模式中的影响</p>
<h1 id="指令重排对单例模式的影响"><a href="#指令重排对单例模式的影响" class="headerlink" title="指令重排对单例模式的影响"></a>指令重排对单例模式的影响</h1><p>首先回顾一下懒汉式DCLP单例模式的代码</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;创建了一个对象&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">CSingleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;销毁了一个对象&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> CSingleton* instance;  </span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CSingleton* CSingleton::instance; </span><br><span class="line"> </span><br><span class="line"><span class="function">CSingleton* <span class="title">CSingleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();    </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == instance)</span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();    </span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意这一句：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();    <span class="comment">//并非一个原子操作，不是可重入函数</span></span><br></pre></td></tr></table></figure></div>
<p><code>instance</code>的初始化其实做了三个事情：</p>
<ul>
<li>①内存分配：为CSingleton对象分配一片内存</li>
<li>②对象构造：调用构造函数构造一个CSingleton对象，存入已分配的内存区</li>
<li>③地址绑定：将指针instance指向这片内存区（执行完这步instance才是非 nullptr）</li>
</ul>
<p>但是由于指令重排，编译器会将顺序改变为：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">instance = <span class="comment">//步骤三</span></span><br><span class="line"><span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(CSingleton));<span class="comment">//步骤一</span></span><br><span class="line"><span class="keyword">new</span>(instance)CSingleton;<span class="comment">//步骤二</span></span><br></pre></td></tr></table></figure></div>
<p>现在考虑以下场景：<br>1.线程A进入getInstance()，判断instance为空，请求加锁，然后执行步骤一和三组成的语句，之后A被挂起。此时instance为非空指针（指向了一块内存），但instance指向内存里面的CSingleton对象还未被构造出来。<br>2.线程B进入getInstance()，判断instance非空（因为在A线程中instance已经为非空指针了），直接返回instance。之后用户使用该指针访问CSingleton对象，嘿！您猜怎么着，这个CSingleton对象还没被构造出来呢。</p>
<p>总的来说，只有步骤一和二在三前面执行，DCLP才有效</p>
<h1 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h1><h2 id="std-call-once和std-once-flag"><a href="#std-call-once和std-once-flag" class="headerlink" title="std::call_once和std::once_flag"></a>std::call_once和std::once_flag</h2><p><code>std::call_once</code>配合<code>std::once_flag</code>确保了<code>instance = new CSingleton()</code>只会被执行一次，无论它被多少个线程访问。这避免了指令重排在多线程下导致的问题。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span>;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> CSingleton* instance;</span><br><span class="line">    <span class="type">static</span> std::once_flag onceFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSingleton* CSingleton::instance;</span><br><span class="line"></span><br><span class="line">std::once_flag CSingleton::onceFlag;</span><br><span class="line"></span><br><span class="line"><span class="function">CSingleton* <span class="title">CSingleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	    call_once和once_flag保证了多线程下仅有一个线程可以执行该函数,因此无需手动加锁</span></span><br><span class="line"><span class="comment">	    而且当 std::call_once 被多次调用时（无论是由同一个线程还是不同的线程）</span></span><br><span class="line"><span class="comment">	    只有第一次调用会执行传递给它的函数</span></span><br><span class="line"><span class="comment">	    所有随后的调用，都不会再次执行该函数</span></span><br><span class="line"><span class="comment">	    */</span></span><br><span class="line">	    std::<span class="built_in">call_once</span>(onceFlag,[]()&#123;instance = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();&#125;);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="std-atomic和内存顺序"><a href="#std-atomic和内存顺序" class="headerlink" title="std::atomic和内存顺序"></a>std::atomic和内存顺序</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">    static std::atomic&lt;CSingleton*&gt; instance;</span></span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::atomic&lt;CSingleton*&gt; CSingleton::instance;</span><br><span class="line"></span><br><span class="line">std::mutex CSingleton::mtx;</span><br><span class="line"></span><br><span class="line"><span class="function">CSingleton* <span class="title">CSingleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//核心框架还是双检查</span></span><br><span class="line">	<span class="comment">//保证了这个读操作之后发生的读写操作不会被重排到这个操作之前</span></span><br><span class="line">    CSingleton* tmp = instance.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == tmp) </span><br><span class="line">    &#123;</span><br><span class="line">           <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">           <span class="comment">//再次获取，检查是否有其他线程在获取锁的过程中创建了实例</span></span><br><span class="line">           tmp = instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">           <span class="keyword">if</span> (<span class="literal">nullptr</span> == tmp) </span><br><span class="line">           &#123;</span><br><span class="line">               tmp = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">               <span class="comment">//保证了在这个写操作之前的所有操作都不会被重排到这个操作之后</span></span><br><span class="line">               <span class="comment">//确保了实例完全构造好之后，其他线程通过 `instance` 读取到的值是最新的</span></span><br><span class="line">               instance.<span class="built_in">store</span>(tmp, std::memory_order_release);</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h2><p>最后，害得是局部静态变量形式的单例模式，大道至简！</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> CSingleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> CSingleton instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>具体原因见：<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18081803" >《单例模式学习》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文讨论了指令重排对多线程下的单例模式的影响，并例举了几个解决方案。后面可能还会更新别的解决方案</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a class="link"   href="https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf" >C++ and the Perils of Double-Checked Locking <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>2.<a class="link"   href="https://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/" >Double-Checked Locking is Fixed In C++11 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++设计模式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习（一）单例模式的几种实现方式</title>
    <url>/2024/03/18/singleton/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>单例模式，其核心目标是确保在程序运行的过程中，有且只有存在一个实例才能保证他们的逻辑正确性以及良好的效率。因此单例模式的实现思路就是确保一个类有且只有一个实例，并提供一个该实例的全局访问点。<br>单例模式设计要点：</p>
<ul>
<li>私有构造、析构</li>
<li>禁止赋值、拷贝</li>
<li>静态私有成员：全局唯一实例</li>
<li>提供一个用于获取全局唯一实例的接口，若实例不存在则创建。</li>
</ul>
<p>除了上面提到的四点还要注意线程安全以及资源释放的问题。</p>
<p>本文从最基本的懒汉式和饿汉式单例模式开始，循序渐进地讨论单例模式形式的特点及变化过程</p>
<h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><p>饿汉式单例模式的核心思路就是不管需不需要用到实例都要去创建实例。饿汉模式的实例在类产生时候就创建了，它的生存周期和程序一样长。</p>
<p>对于饿汉模式而言，是线程安全的，因为在线程创建之前唯一的实例已经被创建好了。而且在程序的退出阶段，类内唯一实例<code>instance</code>也会被销毁，<code>~CSingleton</code>会被调用，资源可以正常被释放。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无延迟初始化</span></span><br><span class="line"><span class="comment">//多线程安全，资源自动释放</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;创建了一个对象&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;销毁了一个对象&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;) 			 = <span class="keyword">delete</span>;</span><br><span class="line">    CSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> CSingleton instance;  <span class="comment">//将指针改为普通的变量</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">CSingleton CSingleton::instance;</span><br><span class="line"></span><br><span class="line"><span class="function">CSingleton* <span class="title">CSingleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试代码，后面不赘述</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Now we get the instance&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]()&#123;<span class="keyword">auto</span> instance = CSingleton::getInstance();&#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]()&#123;<span class="keyword">auto</span> instance = CSingleton::getInstance();&#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([]()&#123;<span class="keyword">auto</span> instance = CSingleton::getInstance();&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Now we destroy the instance&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>测试结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/18/singleton/result_hungry.png"
                     
                ></p>
<p>饿汉式的缺点：</p>
<ul>
<li>在程序启动时立即创建单例对象，若单例类中包含耗时的初始化操作时，会增加程序的启动时间</li>
<li>若有多个单例类分布在不同编译单元，且这些单例类间存在依赖关系，那么在初始化时可能会有问题，因为C++标准不能保证不同编译单元中静态对象的初始化顺序</li>
</ul>
<h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><p>与饿汉式单例模式相比，懒汉式的关键区别在于它延迟了单例实例的创建，即直到第一次被使用时才创建实例：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//延迟初始化</span></span><br><span class="line"><span class="comment">//多线程不安全，资源无法自动释放</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;创建了一个对象&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;销毁了一个对象&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;) 			 = <span class="keyword">delete</span>;</span><br><span class="line">    CSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> CSingleton* instance;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CSingleton* CSingleton::instance; </span><br><span class="line"> </span><br><span class="line"><span class="function">CSingleton* <span class="title">CSingleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == instance)</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>测试结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/18/singleton/result_lazy.png"
                     
                ></p>
<p>但是上述代码有几个缺点：</p>
<ul>
<li><strong>线程安全问题</strong>：多线程环境下不安全，可能会有多个单例实例被创建，这违反了单例模式的原则。</li>
<li><strong>资源释放问题</strong>：运行结束无法自动调用析构函数（因为单例对象建立在堆上，在程序结束时，指针变量被销毁了，而它所指向的堆上的内存并没有被销毁），可能会导致资源泄漏。</li>
</ul>
<p>为了解决线程安全的问题，下面讨论加锁的懒汉式单例模式：</p>
<h1 id="懒汉式DCLP"><a href="#懒汉式DCLP" class="headerlink" title="懒汉式DCLP"></a>懒汉式DCLP</h1><p>为了让懒汉式做到线程安全，我们首先会想到加锁：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CSingleton* CSingleton::instance;</span><br><span class="line"> </span><br><span class="line">std::mutex CSingleton::mtx;</span><br><span class="line"> </span><br><span class="line"><span class="function">CSingleton* <span class="title">CSingleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mtx.<span class="built_in">lock</span>();    </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == instance)</span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();    </span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但是要注意，加锁和解锁的操作是需要时间的，上述方法在多线程的情况下，每次调用都会浪费时间在上锁和解锁上，导致效率下降。其实我们真正需要的，只是在instance 初始化时上锁保证线程安全，即只有<code>getInstance()</code>第一次被调用时上锁才是必要的。若在程序中，<code>getInstance()</code>被调用了n次，那么只有第一次调用锁是起真正作用的，其余n-1次做操作都是没必要的。</p>
<p>所以要想改进上述问题，我们在加锁之前先判个空，当判断结果为真（即<code>instance</code>还没有被初始化），才进行加锁操作，然后再次检查<code>instance</code>是否为空。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双检查锁模式DCLP</span></span><br><span class="line"><span class="function">CSingleton* <span class="title">CSingleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> == instance)</span><br><span class="line">	&#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>();   </span><br><span class="line">	    <span class="keyword">if</span>(<span class="literal">nullptr</span> == instance)</span><br><span class="line">	    &#123;</span><br><span class="line">	        instance = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">	    &#125;</span><br><span class="line">	    mtx.<span class="built_in">unlock</span>(); </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>第二次检查必不可少，这是因为在第一次检查<code>instance </code>和加锁之间，可能会有别的线程对<code>instance </code>进行初始化。</p>
<p>测试结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/18/singleton/result_DCLP.png"
                     
                ></p>
<p>但是遗憾的是，这种方法其实也不是线程安全的，具体原因可见：<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18081876" >补充-指令重排 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>其实，使用了DCLP的懒汉式单例模式不但线程不安全，而且无法通过RAII机制调用析构函数释放相关资源。具体原因可见：<a class="link"   href="https://www.cnblogs.com/paw5zx/p/18081874" >补充-单例模式析构 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>为了解决线程安全问题和资源释放问题，Scott Meyers提出了局部静态变量形式的单例模式。</p>
<h1 id="局部静态式（Meyers’-Singleton）"><a href="#局部静态式（Meyers’-Singleton）" class="headerlink" title="局部静态式（Meyers’ Singleton）"></a>局部静态式（Meyers’ Singleton）</h1><p>这种形式的单例模式使用函数中的局部静态变量来代替类中的静态成员指针：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//延迟初始化</span></span><br><span class="line"><span class="comment">//多线程安全，资源自动释放</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>() &#123;std::cout &lt;&lt; <span class="string">&quot;创建了一个对象&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">CSingleton</span>() &#123;std::cout &lt;&lt; <span class="string">&quot;销毁了一个对象&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">    CSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> CSingleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Now we get the instance&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]()&#123;<span class="keyword">auto</span>&amp; instance = CSingleton::getInstance();&#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]()&#123;<span class="keyword">auto</span>&amp; instance = CSingleton::getInstance();&#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([]()&#123;<span class="keyword">auto</span>&amp; instance = CSingleton::getInstance();&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Now we destroy the instance&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>测试结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/18/singleton/result_meyers.png"
                     
                ></p>
<p><strong>对于线程安全问题</strong>：在C++11及更高版本中，静态局部变量的初始化是线程安全的。即当多个线程同时首次访问局部静态变量，编译器可以保证其初始化代码仅执行一次，防止了任何可能的竞态条件或重复初始化。</p>
<p><strong>对于资源释放问题</strong>：代码中局部静态变量<code>instance</code>的生命周期开始于第一次调用<code>getInstance</code>方法时，终止于程序结束时。在程序的退出阶段局部静态变量<code>instance</code>被销毁，<code>~CSingleton</code>被调用，确保了资源的正确释放。</p>
<h1 id="单例模板"><a href="#单例模板" class="headerlink" title="单例模板"></a>单例模板</h1><p>在大型项目中，如果有多个类都被设计为要具有单例行为，那么为了方便这些类的创建，我们可以将单例属性封装为一个模板类，在需要时继承这个模板基类，这样这些子类就可以继承它的单例属性。</p>
<p>因为这种单例模式是基于静态局部变量的，所以它是多线程安全的而且是可以正常进行资源释放的：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;创建了一个对象&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">CSingleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;销毁了一个对象&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">    CSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> T instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> CSingleton&lt;MyClass&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CSingleton</span>&lt;MyClass&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;this is MyClass construct&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;this is MyClass destruct&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;dosomething&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>测试结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/03/18/singleton/result_CRTP.png"
                     
                ></p>
<p>这种形式使用了奇异递归模板模式（Curiously Recurring Template Pattern, CRTP）。在使用时要注意，子类需要将自己作为模板参数传递给CSingleton模板进行模板类实例化，用做基类；同时需要将基类声明为友元，这样才能在通过<code>CSingleton&lt;T&gt;::getInstance()</code>方法创建MyClass唯一实例时，调用到MyClass的私有构造函数。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>1.<a class="link"   href="https://blog.csdn.net/qq_43331089/article/details/124340554" >C++ 单例模式 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++设计模式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>jsoncpp的安装及使用</title>
    <url>/2024/06/13/thirdlib-jsoncpp/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文操作均在ubuntu20.04下进行。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="方法一：apt包管理器"><a href="#方法一：apt包管理器" class="headerlink" title="方法一：apt包管理器"></a>方法一：apt包管理器</h2><p><strong>①使用包管理器安装</strong><br>这种方法比较简单，直接使用apt包管理器安装jsoncpp：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt install libjsoncpp-dev</span><br></pre></td></tr></table></figure></div>
<p>这条命令会安装jsoncpp的开发库和必需的文件</p>
<p><strong>②查看头文件和库文件</strong><br>安装完毕后我们可以去找一下jsoncpp的头文件和库文件<br>头文件位于<code>/usr/include/jsoncpp/json/</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/13/thirdlib-jsoncpp/location.png"
                     
                ></p>
<p>库文件位于<code>/usr/lib/x86_64-linux-gnu/</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/13/thirdlib-jsoncpp/libfile.png"
                     
                ></p>
<p>但是我们通过头文件的version.h和动态库文件的realname，可以知道使用apt包管理器安装的jsoncpp的版本号为1.7.4<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/13/thirdlib-jsoncpp/apt.png"
                     
                ></p>
<p>那如果我需要安装的是jsoncpp的其他版本，就需要下载源代码并编译安装。</p>
<h2 id="方法二：源码编译安装"><a href="#方法二：源码编译安装" class="headerlink" title="方法二：源码编译安装"></a>方法二：源码编译安装</h2><p><strong>①在开始编译前，首先要确保系统中安装了<code>g++</code>和<code>cmake</code></strong></p>
<p><strong>②下载jsoncpp源码</strong><br>从github下载jsoncpp的特定版本并解压，以1.9.3为例：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/open-source-parsers/jsoncpp/archive/1.9.3.tar.gz</span><br><span class="line">tar xzf 1.9.3.tar.gz</span><br></pre></td></tr></table></figure></div>
<p><strong>③编译和安装</strong><br>进入jsoncpp目录，使用cmake来配置项目并编译安装：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> jsoncpp-1.9.3</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DBUILD_SHARED_LIBS=ON</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>
<p>注意，在<code>cmake ..</code>后面加上了<code>-DBUILD_SHARED_LIBS=ON</code>选项，会生成静态库和共享库。若不添加，则只会生成静态库。</p>
<p><strong>④查看头文件和库文件</strong><br>通过此方法安装的jsoncpp，其头文件位于<code>/usr/local/include/json/</code>，库文件位于<code>/usr/local/lib/</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/source_loaction.png"
                     
                ></p>
<p>也不知道为啥，1.9.3版本的共享库soname是<code>libjsoncpp.so.24</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/13/thirdlib-jsoncpp/source_soname.png"
                     
                ></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="编写示例代码"><a href="#编写示例代码" class="headerlink" title="编写示例代码"></a>编写示例代码</h2><h3 id="写JSON"><a href="#写JSON" class="headerlink" title="写JSON"></a>写JSON</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Json::Value对象</span></span><br><span class="line">    Json::Value root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对象中添加数据</span></span><br><span class="line">    root[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">    root[<span class="string">&quot;age&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    root[<span class="string">&quot;isAlive&quot;</span>] = <span class="literal">true</span>;</span><br><span class="line">    root[<span class="string">&quot;address&quot;</span>][<span class="string">&quot;city&quot;</span>] = <span class="string">&quot;New York&quot;</span>;</span><br><span class="line">    root[<span class="string">&quot;address&quot;</span>][<span class="string">&quot;state&quot;</span>] = <span class="string">&quot;NY&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Json::StreamWriterBuilder</span></span><br><span class="line">    Json::StreamWriterBuilder writer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Json::Value对象转换为字符串</span></span><br><span class="line">    std::string output = Json::<span class="built_in">writeString</span>(writer, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印输出</span></span><br><span class="line">    std::cout &lt;&lt; output &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="读JSON"><a href="#读JSON" class="headerlink" title="读JSON"></a>读JSON</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// JSON字符串</span></span><br><span class="line">    std::string jsonString = <span class="string">R&quot;(&#123;&quot;name&quot;:&quot;John Doe&quot;,&quot;age&quot;:30,&quot;isAlive&quot;:true,&quot;address&quot;:&#123;&quot;city&quot;:&quot;New York&quot;,&quot;state&quot;:&quot;NY&quot;&#125;&#125;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Json::CharReaderBuilder</span></span><br><span class="line">    Json::CharReaderBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Json::Value对象</span></span><br><span class="line">    Json::Value root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个错误信息字符串</span></span><br><span class="line">    std::string errors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析JSON字符串</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Json::CharReader&gt; <span class="title">reader</span><span class="params">(builder.newCharReader())</span></span>;</span><br><span class="line">    <span class="type">bool</span> parsingSuccessful = reader-&gt;<span class="built_in">parse</span>(jsonString.<span class="built_in">c_str</span>(), jsonString.<span class="built_in">c_str</span>() + jsonString.<span class="built_in">size</span>(), &amp;root, &amp;errors);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!parsingSuccessful) &#123;</span><br><span class="line">        <span class="comment">// 打印错误信息并退出</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error parsing JSON: &quot;</span> &lt;&lt; errors &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取并打印数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; root[<span class="string">&quot;name&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; root[<span class="string">&quot;age&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is Alive: &quot;</span> &lt;&lt; (root[<span class="string">&quot;isAlive&quot;</span>].<span class="built_in">asBool</span>() ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;City: &quot;</span> &lt;&lt; root[<span class="string">&quot;address&quot;</span>][<span class="string">&quot;city&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; root[<span class="string">&quot;address&quot;</span>][<span class="string">&quot;state&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h2><p>具体操作略<br>注意链接时要加上<code>-ljsoncpp</code></p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><h3 id="写JSON-1"><a href="#写JSON-1" class="headerlink" title="写JSON"></a>写JSON</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/13/thirdlib-jsoncpp/result_write.png"
                     
                ></p>
<h3 id="读JSON-1"><a href="#读JSON-1" class="headerlink" title="读JSON"></a>读JSON</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/13/thirdlib-jsoncpp/result_read.png"
                     
                ></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>三方库</category>
      </categories>
  </entry>
  <entry>
    <title>log4cpp的安装及使用</title>
    <url>/2024/07/15/thirdlib-log4cpp/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的操作均在ubuntu20.04下进行</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>本文仅介绍从源码编译安装log4cpp的过程。</p>
<p><strong>①在开始编译前，首先要确保系统中安装了<code>g++</code>，<code>make</code>，<code>autoconf</code>和<code>libtool</code></strong></p>
<p><strong>②下载log4cpp源码</strong><br>下载log4cpp的特定版本并解压，以1.1.3为例：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://sourceforge.net/projects/log4cpp/files/log4cpp-1.1.3.tar.gz</span><br><span class="line">tar -xvzf log4cpp-1.1.3.tar.gz</span><br></pre></td></tr></table></figure></div>
<p><strong>③编译和安装</strong><br>进入log4cpp目录，使用autoconf来配置项目并编译安装：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> log4cpp</span><br><span class="line"><span class="comment"># 默认安装</span></span><br><span class="line">./configure</span><br><span class="line"><span class="comment"># 或指定安装路径</span></span><br><span class="line"><span class="comment"># ./configure --prefix=/path/to/file</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>
<p><strong>④查看头文件和库文件</strong><br>默认配置安装的log4cpp，其头文件位于<code>/usr/local/include/log4cpp/</code>，库文件位于<code>/usr/local/lib/</code>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/15/thirdlib-log4cpp/location.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/15/thirdlib-log4cpp/location2.png"
                     
                ></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log4cpp/PropertyConfigurator.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log4cpp/Category.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      log4cpp::PropertyConfigurator::<span class="built_in">configure</span>(<span class="string">&quot;./cfg/log4cfg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (log4cpp::ConfigureFailure&amp; f)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;configure problem &quot;</span> &lt;&lt; f.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    log4cpp::Category &amp; log = log4cpp::Category::<span class="built_in">getRoot</span>();</span><br><span class="line"></span><br><span class="line">    std::string s = __FILE__;</span><br><span class="line">    s += <span class="string">&quot; : &quot;</span>;</span><br><span class="line">    std::ostringstream line;</span><br><span class="line">    line &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; __LINE__;</span><br><span class="line">    s += line.<span class="built_in">str</span>();</span><br><span class="line">    s += <span class="string">&quot; : &quot;</span>;</span><br><span class="line">    std::ostringstream  buf;</span><br><span class="line">    buf&lt;&lt; <span class="string">&quot;test message&quot;</span>; ;</span><br><span class="line">    s += buf.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    log.<span class="built_in">info</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">#顶级父元素配置</span><br><span class="line">log4cpp.rootCategory=INFO,console,file</span><br><span class="line">#文件输出配置</span><br><span class="line">log4cpp.appender.file=RollingFileAppender        #滚动文件</span><br><span class="line">log4cpp.appender.file.fileName=./log/data.log    #文件名称</span><br><span class="line">log4cpp.appender.file.maxFileSize=524288000      #单个文件大小</span><br><span class="line">log4cpp.appender.file.maxBackupIndex=10          #文件保存数量</span><br><span class="line">log4cpp.appender.file.backupPattern=%Y-%m-%d    </span><br><span class="line">log4cpp.appender.file.layout=PatternLayout       #layout格式</span><br><span class="line">log4cpp.appender.file.layout.ConversionPattern=[%d&#123;%Y-%m-%d %H:%M:%S,%l&#125;](%p)&lt;%t&gt;%c %x: %m%n    #输出格式</span><br><span class="line"></span><br><span class="line">#控制台输出配置       </span><br><span class="line">log4cpp.appender.console=ConsoleAppender</span><br><span class="line">log4cpp.appender.console.layout=PatternLayout</span><br><span class="line">log4cpp.appender.console.layout.ConversionPattern=[%d&#123;%Y-%m-%d %H:%M:%S,%l&#125;](%p)&lt;%t&gt;%c %x: %m%n</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h2 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h2><p>具体操作略<br>注意链接时要加上<code>-llog4cpp -lpthread</code></p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/15/thirdlib-log4cpp/result.png"
                     
                ></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>三方库</category>
      </categories>
  </entry>
</search>
